/** Get the first element */
export type TupleHead<T extends unknown[]> = T[0];
/** Remove the first element */
export type TupleTail<T extends unknown[]> = T extends [] ? [] : T extends [unknown] ? [] : T extends [unknown, ...infer U] ? U : unknown[];
export type TupleShift<T extends unknown[]> = TupleTail<T>;
/** Get the last element */
export type TupleLast<T extends any[]> = T[TupleTail<T>['length']];
/** Remove the last element */
export type TupleRemoveLast<T extends any[]> = TypeAssert<Overwrite<TupleTail<T>, T>, any[]>;
/** Insert element at first */
export type TupleUnshift<T extends unknown[], X> = [X, ...T];
/** Append element at last */
export type TuplePush<T extends any[], X> = [...T, X];
/** Concat two tuples */
export type TupleConcat<A extends unknown[], B extends unknown[]> = [...A, ...B];
export type TypeAssert<T, A> = T extends A ? T : never;
export type Overwrite<T, S> = {
    [P in keyof T]: S[P];
};
/**
 * Whether literal type is in Tuple contains literal,
 *
 * @example ```ts
 * type Foo = isInType<['ab', 'cd'], 'ab'>
 * ```
 * @returns boolean
 */
export type isInLiteralTuple<T extends (string | number | symbol)[], K extends string | number | symbol> = [Extract<T[number], K>] extends [never] ? false : true;
export type TupleToUnion<T extends any[] | readonly any[]> = T[number];
export type Reverse<Tuple extends any[]> = Reverse_<Tuple, []>;
type Reverse_<Tuple extends any[], Result extends any[]> = {
    1: Result;
    0: Reverse_<TupleTail<Tuple>, TupleUnshift<Result, TupleHead<Tuple>>>;
}[Tuple extends [] ? 1 : 0];
export type FlattenNestedTuple<T extends (readonly any[])> = {
    [K in keyof T]: FlattenTuple<T[K]>;
};
/**
 * Convert const type to type const input = [1, 2] as const
 * @example ```ts
 * const input = [1, [2, 3]] as const  // note the `as const`
 * type Result = FlattenTuple<typeof input> // [1, 2 | 3]
 * ```
 *
 */
type FlattenTuple<T> = T extends readonly (infer U)[] ? U extends ((any)[]) ? TupleToUnion<U> : U : T;
export {};
