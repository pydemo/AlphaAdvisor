import assert from 'node:assert';
export class LoaderCache {
    static cacheLibMap = new Map();
    static regCacheMap = new WeakMap();
    static multipleChoiceMapperList = new WeakMap();
    /**
     * Get function by definition arguments of the function
     */
    static getFuncByDefArgs(lib, fnName, defArgs) {
        assert(defArgs.length > 1, 'runtimeDefArgs.length must > 1');
        const map = LoaderCache.getRegisteredFuncMap(lib, fnName);
        return map?.get(defArgs);
    }
    /**
     * Get function definition arguments
     */
    static getFnDefArgs(lib, fnName) {
        const cacheMap = LoaderCache.regCacheMap.get(lib);
        const map = cacheMap?.get(fnName);
        return map ? [...map.keys()] : [];
    }
    // #region cacheLibMap
    static getLibByName(dllName) {
        return LoaderCache.cacheLibMap.get(dllName);
    }
    static setLibByName(dllName, lib) {
        LoaderCache.cacheLibMap.set(dllName, lib);
    }
    static removeLibByName(dllName) {
        LoaderCache.cacheLibMap.delete(dllName);
    }
    // #region regCacheMap
    static getRegisteredFunc(lib, fnName) {
        const cacheMap = LoaderCache.regCacheMap.get(lib);
        const map = cacheMap?.get(fnName);
        if (map?.size) {
            const arr = map.entries().next().value;
            const ret = arr?.[1];
            return ret;
        }
    }
    /**
     *
     * @note return Map<FnDefArgs, KoffiFunction> | undefined
     */
    static getRegisteredFuncMap(lib, fnName) {
        const cacheMap = LoaderCache.regCacheMap.get(lib);
        return cacheMap?.get(fnName);
    }
    static setRegisteredFuncToCache(lib, name, fn, defArgs) {
        let map1 = LoaderCache.regCacheMap.get(lib);
        if (!map1) {
            map1 = new Map();
            LoaderCache.regCacheMap.set(lib, map1);
        }
        let map2 = map1.get(name);
        if (!map2) {
            map2 = new Map();
            map1.set(name, map2);
        }
        map2.set([...defArgs], fn);
    }
    static removeRegisteredFuncFromCache(lib, name) {
        const cacheMap = LoaderCache.regCacheMap.get(lib);
        cacheMap?.delete(name);
    }
    // #region multipleChoiceMapperList
    /**
     * Get multiple choice list mapper by function name, return Set
     *
     */
    static getMultipleChoiceListMapperSet(lib, fnName) {
        return LoaderCache.multipleChoiceMapperList.get(lib)?.get(fnName);
    }
    static updateMultipleChoiceListMapper(lib, fnMapperList) {
        let map = LoaderCache.multipleChoiceMapperList.get(lib);
        if (!map) {
            map = new Map();
            LoaderCache.multipleChoiceMapperList.set(lib, fnMapperList);
        }
        fnMapperList.forEach((fnMappers, fnName) => {
            const set = map.get(fnName);
            if (set) {
                fnMappers.forEach(fn => set.add(fn));
            }
            else {
                map.set(fnName, fnMappers);
            }
        });
    }
    static removeMultipleChoiceListMapper(lib, fnName) {
        LoaderCache.multipleChoiceMapperList.get(lib)?.delete(fnName);
    }
}
//# sourceMappingURL=loader.cache.js.map