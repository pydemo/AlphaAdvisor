/**
 * win32-def
 * win32 definitions for node-ffi
 *
 * @version 26.1.1
 * @author waiting
 * @license MIT
 * @link https://waitingsong.github.io/node-win32-api
 */

'use strict';

var ffi = require('koffi');
var assert = require('node:assert');

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * @link https://koffi.dev/functions#calling-conventions
 */
exports.CallingConvention = void 0;
(function (CallingConvention) {
    CallingConvention["Cdecl"] = "";
    CallingConvention["Stdcall"] = "__stdcall";
    CallingConvention["Fastcall"] = "__fastcall";
    CallingConvention["Thiscall"] = "__thiscall";
})(exports.CallingConvention || (exports.CallingConvention = {}));

// dict of windef value
const config = {
    _WIN64: process.arch === 'x64',
};
const loadOptionsDefault = {
    _WIN64: config._WIN64,
    convention: exports.CallingConvention.Cdecl,
    autoCreateStruct: true,
};

/**
 * @link https://koffi.dev/input
 * @link https://tootallnate.github.io/ref/
 */
exports.Def = void 0;
(function (Def) {
    Def["bool"] = "bool";
    Def["byte"] = "uint8_t";
    Def["int"] = "int";
    Def["int8"] = "int8_t";
    Def["int16"] = "int16_t";
    Def["int32"] = "int32_t";
    Def["int64"] = "int64_t";
    Def["float"] = "float";
    Def["long"] = "long";
    Def["longlong"] = "longlong";
    // ptr = 'pointer',
    Def["uchar"] = "uchar";
    Def["uint"] = "uint";
    Def["uint8"] = "uint8_t";
    Def["uint16"] = "uint16_t";
    Def["uint32"] = "uint32_t";
    Def["uint64"] = "uint64_t";
    Def["ulong"] = "ulong";
    Def["ulonglong"] = "ulonglong";
    Def["ushort"] = "ushort";
    Def["void"] = "void";
    Def["boolPtr"] = "bool*";
    Def["bytePtr"] = "uint8_t*";
    Def["charPtr"] = "char*";
    Def["intPtr"] = "int*";
    Def["int8Ptr"] = "int8_t*";
    Def["int16Ptr"] = "int16_t*";
    Def["int32Ptr"] = "int32_t*";
    Def["int64Ptr"] = "int64_t*";
    Def["floatPtr"] = "float*";
    Def["longPtr"] = "long*";
    Def["uintPtr"] = "uint*";
    Def["uint8Ptr"] = "uint8_t*";
    Def["intPtrPtr"] = "int**";
    Def["uint16Ptr"] = "uint16_t*";
    Def["uint32Ptr"] = "uint32_t*";
    Def["uint64Ptr"] = "uint64_t*";
    Def["ulonglongPtr"] = "ulonglong*";
    Def["voidPtr"] = "void*";
    Def["uintPtrPtr"] = "uint**";
    Def["uint16PtrPtr"] = "uint16_t**";
    Def["uint32PtrPtr"] = "uint32_t**";
    Def["uint64PtrPtr"] = "uint64_t**";
    Def["ulonglongPtrPtr"] = "ulonglong**";
    Def["voidPtrPtr"] = "void**";
})(exports.Def || (exports.Def = {}));

// #region processDefList()
function processDefList(dllFuncs, fns) {
    const map = genDefList(dllFuncs);
    const map2 = new Map();
    if (fns && Array.isArray(fns) && fns.length) {
        fns.forEach((fnName) => {
            if (fnName.endsWith('_Async')) {
                const syncFnName = fnName.replace(/_Async$/u, '');
                const data = map.get(syncFnName);
                if (data) {
                    map2.set(syncFnName, data);
                }
            }
            else { // sync
                const data = map.get(fnName);
                if (data) {
                    map2.set(fnName, data);
                }
            }
        });
        return map2;
    }
    return map;
}
// #region genDefList()
/**
 * Generate function definitions via converting macro windows data type (like PVOID) to the expected value.
 */
function genDefList(dllFuncs) {
    const ret = typeof dllFuncs === 'function'
        ? genListFromClass(dllFuncs) // class def
        : genListFromObject(dllFuncs); // const def
    return ret;
}
function genListFromObject(input) {
    const ret = new Map();
    for (const fnName of Object.keys(input)) {
        // @ts-ignore
        const ps = input[fnName];
        if (Array.isArray(ps) && ps.length === 2) {
            assert(ps[0] && ps[1], `dellFuncs has no property method name "${fnName}"`);
            assert(typeof ps[0] === 'string', `dellFuncs has no property method name "${fnName}"`);
            ret.set(fnName, ps);
        }
    }
    return ret;
}
function genListFromClass(input) {
    assert(typeof input === 'function', 'input must be a class');
    const ret = new Map();
    for (const key in input) {
        // @ts-ignore
        const ps = input[key];
        if (Array.isArray(ps) && ps.length === 2) {
            assert(ps[0] && ps[1], `dellFuncs has no property method name "${key}"`);
            assert(typeof ps[0] === 'string', `dellFuncs has no property method name "${key}"`);
            ret.set(key, ps);
        }
    }
    return ret;
}

class LoaderCache {
    static cacheLibMap = new Map();
    static regCacheMap = new WeakMap();
    static multipleChoiceMapperList = new WeakMap();
    /**
     * Get function by definition arguments of the function
     */
    static getFuncByDefArgs(lib, fnName, defArgs) {
        assert(defArgs.length > 1, 'runtimeDefArgs.length must > 1');
        const map = LoaderCache.getRegisteredFuncMap(lib, fnName);
        return map?.get(defArgs);
    }
    /**
     * Get function definition arguments
     */
    static getFnDefArgs(lib, fnName) {
        const cacheMap = LoaderCache.regCacheMap.get(lib);
        const map = cacheMap?.get(fnName);
        return map ? [...map.keys()] : [];
    }
    // #region cacheLibMap
    static getLibByName(dllName) {
        return LoaderCache.cacheLibMap.get(dllName);
    }
    static setLibByName(dllName, lib) {
        LoaderCache.cacheLibMap.set(dllName, lib);
    }
    static removeLibByName(dllName) {
        LoaderCache.cacheLibMap.delete(dllName);
    }
    // #region regCacheMap
    static getRegisteredFunc(lib, fnName) {
        const cacheMap = LoaderCache.regCacheMap.get(lib);
        const map = cacheMap?.get(fnName);
        if (map?.size) {
            const arr = map.entries().next().value;
            const ret = arr?.[1];
            return ret;
        }
    }
    /**
     *
     * @note return Map<FnDefArgs, KoffiFunction> | undefined
     */
    static getRegisteredFuncMap(lib, fnName) {
        const cacheMap = LoaderCache.regCacheMap.get(lib);
        return cacheMap?.get(fnName);
    }
    static setRegisteredFuncToCache(lib, name, fn, defArgs) {
        let map1 = LoaderCache.regCacheMap.get(lib);
        if (!map1) {
            map1 = new Map();
            LoaderCache.regCacheMap.set(lib, map1);
        }
        let map2 = map1.get(name);
        if (!map2) {
            map2 = new Map();
            map1.set(name, map2);
        }
        map2.set([...defArgs], fn);
    }
    static removeRegisteredFuncFromCache(lib, name) {
        const cacheMap = LoaderCache.regCacheMap.get(lib);
        cacheMap?.delete(name);
    }
    // #region multipleChoiceMapperList
    /**
     * Get multiple choice list mapper by function name, return Set
     *
     */
    static getMultipleChoiceListMapperSet(lib, fnName) {
        return LoaderCache.multipleChoiceMapperList.get(lib)?.get(fnName);
    }
    static updateMultipleChoiceListMapper(lib, fnMapperList) {
        let map = LoaderCache.multipleChoiceMapperList.get(lib);
        if (!map) {
            map = new Map();
            LoaderCache.multipleChoiceMapperList.set(lib, fnMapperList);
        }
        fnMapperList.forEach((fnMappers, fnName) => {
            const set = map.get(fnName);
            if (set) {
                fnMappers.forEach(fn => set.add(fn));
            }
            else {
                map.set(fnName, fnMappers);
            }
        });
    }
    static removeMultipleChoiceListMapper(lib, fnName) {
        LoaderCache.multipleChoiceMapperList.get(lib)?.delete(fnName);
    }
}

// windows data types for ref module https://github.com/TooTallNate/ref
// https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751
const { _WIN64 } = config;
/**
 * @link https://docs.microsoft.com/en-us/windows/win32/secauthz/access-mask-format
 */
const ACCESS_MASK = exports.Def.int32;
const ATOM = exports.Def.uint16;
const DWORD = exports.Def.uint32;
_WIN64 ? exports.Def.uint64Ptr : exports.Def.uint32Ptr;
const PVOID = exports.Def.voidPtr;
/**
 * `uint32` or `uint64` used as value usage (memory address) instead of PVOID (Buffer),
 * Use `HANDLE` (number) for params definition of the api,
 * @see https://stackoverflow.com/questions/18266626/what-is-the-range-of-a-windows-handle-on-a-64-bits-application/29526711#29526711
 */
const HANDLE = _WIN64 ? exports.Def.uint64 : exports.Def.uint32;
const LONG_PTR = _WIN64 ? exports.Def.int64 : exports.Def.int32;
const ULONG_PTR = _WIN64 ? exports.Def.int64 : exports.Def.int32;
exports.Def.void;
exports.Def.uint16;
const WORD = exports.Def.int16;
const BOOL = exports.Def.int32;
exports.Def.bool;
const BYTE = exports.Def.byte;
exports.Def.uint8;
exports.Def.uint8;
// export const CONST;
exports.Def.uint64;
exports.Def.uint32;
exports.Def.uint64;
exports.Def.float;
_WIN64 ? exports.Def.int32 : exports.Def.int16;
const HBRUSH = HANDLE;
const HCURSOR = HANDLE;
const HICON = HANDLE;
const HINSTANCE = HANDLE;
exports.Def.long;
const HWND = HANDLE;
/** A 32-bit signed integer */
const INT = exports.Def.int;
_WIN64 ? exports.Def.int64Ptr : exports.Def.int32Ptr;
exports.Def.int8;
exports.Def.int16;
exports.Def.int32;
exports.Def.int64;
const LONG = exports.Def.long;
exports.Def.longlong;
exports.Def.int32;
exports.Def.int64;
const LPARAM = LONG_PTR;
exports.Def.bytePtr;
exports.Def.int8Ptr;
exports.Def.int16Ptr;
exports.Def.int16Ptr;
exports.Def.voidPtr;
exports.Def.uint16Ptr;
_WIN64 ? exports.Def.int64Ptr : exports.Def.int32Ptr;
exports.Def.int32Ptr;
exports.Def.charPtr;
exports.Def.uint16Ptr;
const LPTSTR = exports.Def.uint16Ptr;
exports.Def.uint16Ptr;
exports.Def.uint32;
exports.Def.boolPtr;
exports.Def.bytePtr;
exports.Def.charPtr;
exports.Def.uint8Ptr;
_WIN64 ? exports.Def.int16Ptr : exports.Def.int8Ptr;
exports.Def.uint16Ptr;
exports.Def.uint32Ptr;
exports.Def.uint64Ptr;
exports.Def.uint32Ptr;
exports.Def.uint64Ptr;
exports.Def.floatPtr;
_WIN64 ? exports.Def.uint64PtrPtr : exports.Def.uint32PtrPtr;
_WIN64 ? exports.Def.uint64PtrPtr : exports.Def.uint32PtrPtr;
exports.Def.intPtrPtr;
exports.Def.int8Ptr;
exports.Def.int16Ptr;
exports.Def.int32Ptr;
exports.Def.int64Ptr;
exports.Def.uint32Ptr;
exports.Def.longPtr;
exports.Def.int64Ptr;
exports.Def.int32Ptr;
exports.Def.int64Ptr;
// ? A 32-bit pointer. On a 32-bit system, this is a native pointer.
// On a 64-bit system, this is a truncated 64-bit pointer.
_WIN64 ? exports.Def.int32Ptr : exports.Def.int32Ptr;
// ? A 64-bit pointer. On a 64-bit system, this is a native pointer.
// On a 32-bit system, this is a sign-extended 32-bit pointer.
_WIN64 ? exports.Def.int64Ptr : exports.Def.int32Ptr;
exports.Def.int16Ptr;
exports.Def.charPtr;
exports.Def.int16Ptr;
exports.Def.uint16Ptr;
exports.Def.uint16Ptr;
const PUINT = exports.Def.uintPtr;
exports.Def.uintPtrPtr;
exports.Def.uint8Ptr;
exports.Def.uint16Ptr;
exports.Def.uint32Ptr;
exports.Def.uint64Ptr;
exports.Def.uintPtr;
exports.Def.uint64Ptr;
exports.Def.uint64PtrPtr;
exports.Def.uintPtr;
exports.Def.uint64Ptr;
exports.Def.uint16Ptr;
exports.Def.uint16Ptr;
exports.Def.uint16Ptr;
exports.Def.uint16Ptr;
exports.Def.uint64;
const SHORT = exports.Def.int16;
exports.Def.int16;
exports.Def.uint16;
exports.Def.uchar;
_WIN64 ? exports.Def.uint32 : exports.Def.uint16;
const UINT = exports.Def.uint;
const UINT_PTR = _WIN64 ? exports.Def.uint64 : exports.Def.uint32;
exports.Def.uint8;
const UINT16 = exports.Def.uint16;
const UINT32 = exports.Def.uint32;
exports.Def.uint64;
const ULONG = exports.Def.uint;
exports.Def.uint64;
exports.Def.uint32;
exports.Def.uint64;
const USHORT = exports.Def.ushort;
const WNDPROC = exports.Def.voidPtr;
exports.Def.voidPtr;
/**
 * Note: original be typedef UINT_PTR WPARAM;
 * CALLBACK WNDCLASSEX.lpfnWndProc may pass negative number and cause process exit.
 */
const WPARAM = UINT_PTR;
/**
 * For 'str16' from https://koffi.dev/input
 */
const WString = 'str16';

class StructUnionCache {
    static cacheStructMap = new Map();
    static cacheUnionMap = new Map();
    // #region STRUCT
    static getStruct(key) {
        assert(key, `key is empty`);
        return StructUnionCache.cacheStructMap.get(key);
    }
    static setStruct(key, value) {
        assert(key, `key is empty`);
        StructUnionCache.cacheStructMap.set(key, value);
    }
    static removeStruct(key) {
        assert(key, `key is empty`);
        return StructUnionCache.cacheStructMap.delete(key);
    }
    // #region UNION
    static getUnion(key) {
        assert(key, `key is empty`);
        return StructUnionCache.cacheUnionMap.get(key);
    }
    static setUnion(key, value) {
        assert(key, `key is empty`);
        StructUnionCache.cacheUnionMap.set(key, value);
    }
    static removeUnion(key) {
        assert(key, `key is empty`);
        return StructUnionCache.cacheUnionMap.delete(key);
    }
}

// #region genSimpleStruct()
/**
 * Generate a simple struct
 * - def must has no nested struct or union
 */
function genSimpleStruct(def, name, pointer) {
    const key = name ? name.trim() : '';
    let ptr = pointer ?? '';
    if (key && !ptr) {
        ptr = key + ' *';
    }
    if (key) {
        const data = StructUnionCache.getStruct(key);
        if (data) {
            return data;
        }
    }
    let ret;
    if (key) {
        const type = ffi.struct(key, def);
        const size = ffi.sizeof(type);
        ret = { name: key, pointer: ptr, CType: type, size };
        StructUnionCache.setStruct(key, ret); // cache named struct only
    }
    else {
        const type = ffi.struct(def);
        const size = ffi.sizeof(type);
        ret = { name: key, pointer: ptr, CType: type, size };
    }
    assert(ret, `ret is null or undefined`);
    return ret;
}
// #region genSimpleUnion()
function genSimpleUnion(def, name, pointer) {
    const key = name ? name.trim() : '';
    let ptr = pointer ? pointer.trim() : '';
    if (key && !ptr) {
        ptr = key + ' *';
    }
    if (key) {
        const data = StructUnionCache.getUnion(key);
        if (data) {
            return data;
        }
    }
    let ret;
    if (key) {
        const type = ffi.union(key, def);
        const size = ffi.sizeof(type);
        ret = { name: key, pointer: ptr, CType: type, size };
        StructUnionCache.setUnion(key, ret); // cache named union only
    }
    else {
        const type = ffi.union(def);
        const size = ffi.sizeof(type);
        ret = { name: key, pointer: ptr, CType: type, size };
    }
    return ret;
}

// #region genStruct()
/**
 * Generate a complex struct,
 * def can have nested struct or union
 * - key s{number} means struct
 * - key u{number} means union
 */
function genStruct(def, name, pointer, sizeColumns) {
    const struct = genComplexStruct(def, name, pointer);
    bindPayloadGetter(struct, sizeColumns);
    return struct;
}
function bindPayloadGetter(struct, sizeColumns) {
    if (typeof struct.sizeColumns === 'undefined') {
        Object.defineProperty(struct, 'sizeColumns', {
            enumerable: true,
            writable: false,
            value: sizeColumns,
        });
    }
    if (typeof struct.payload === 'undefined') {
        // payload must be the new one after each call of the struct factory function
        Object.defineProperty(struct, 'payload', {
            get: function () {
                if (!this.sizeColumns?.length) {
                    return {};
                }
                const ret = {};
                this.sizeColumns.forEach((key) => {
                    if (key) {
                        Object.defineProperty(ret, key, {
                            enumerable: true,
                            writable: false,
                            value: this.size,
                        });
                    }
                });
                return ret;
            },
        });
    }
}
// #region genComplexStruct()
/**
 * Generate a complex struct,
 * def can have nested struct or union
 * - key s{number} means struct
 * - key u{number} means union
 */
function genComplexStruct(def, name, pointer) {
    const key = name ? name.trim() : '';
    const ret = genStructCached(def, key, pointer);
    if (name) {
        assert(ret.name === key, `name: "${ret.name}" !== "${key}"`);
    }
    return ret;
}
const regStructName = /^s\d*$/u;
const regUnionName = /^u\d*$/u;
function genStructCached(def, name, pointer) {
    if (name) {
        const data = StructUnionCache.getStruct(name);
        if (data) {
            return data;
        }
    }
    const data = { ...def };
    // detect nested struct or union, key name start at "s{number*}" means struct, start at "u{number*}" means union
    genItem(data);
    const ret = genSimpleStruct(data, name, pointer);
    return ret;
}
// @region genUnion()
function genUnion(def, name, pointer) {
    const key = name ? name.trim() : '';
    let pname = pointer ?? '';
    if (key && !pname) {
        pname = key + '*';
    }
    const ret = genUnionCached(def, key, pname);
    if (name) {
        assert(ret.name === key, `name: ${ret.name} !== ${key}`);
    }
    return ret;
}
function genUnionCached(def, name, pointer) {
    if (name) {
        const data = StructUnionCache.getUnion(name);
        if (data) {
            return data;
        }
    }
    const data = { ...def };
    // detect nested struct or union, key name start at "s{number*}" means struct, start at "u{number*}" means union
    genItem(data);
    const ret = genSimpleUnion(data, name, pointer);
    return ret;
}
function genItem(data) {
    // detect nested struct or union, key name start at "s{number*}" means struct, start at "u{number*}" means union
    Object.keys(data).forEach((key) => {
        const value = data[key];
        assert(value, `value of key ${key} is null or undefined`);
        if (typeof value === 'string') {
            return;
        }
        if (typeof value === 'function') {
            const nested = value();
            assert(nested, `nested struct must be an object, but got ${typeof nested}`);
            data[key] = nested.CType;
        }
        else if (typeof value === 'object') {
            // Do not check value, because it can be KoffiCType
            // assert(Object.keys(value).length > 0, `value of key ${key} is empty object`)
            if (regStructName.test(key)) {
                const nested = genComplexStruct(value); // do not pass key
                data[key] = nested.CType;
            }
            else if (regUnionName.test(key)) {
                const nested = genUnion(value); // do not pass key
                data[key] = nested.CType;
            }
            else if (Object.keys(value).length === 0) {
                return; // maybe fix array
            }
            /* c8 ignore next 3 */
            else {
                assert(false, `key ${key} must start with 's' or 'u'`);
            }
        }
        /* c8 ignore next 3 */
        else {
            assert(data[key], `value of key ${key} is null or undefined`);
        }
    });
}
/**
 * Generate a fixed int16_t array.
 * convert it back to string through decodeInt16Array()
 */
function genFixedInt16Array(length) {
    assert(length > 0, `length must be greater than 0, but got ${length}`);
    const type = ffi.array('int16_t', length);
    return type;
}
function genFixedArray(length) {
    assert(length > 0, `length must be greater than 0, but got ${length}`);
    const type = ffi.array('int16_t', length, 'Array');
    return type;
}

const key$A = 'INITCOMMONCONTROLSEX';
const ptr$A = `${key$A}*`;
const init$A = {
    dwSize: DWORD,
    dwICC: DWORD,
};
const LPINITCOMMONCONTROLSEX = ptr$A;
const INITCOMMONCONTROLSEX_Name = key$A;
const INITCOMMONCONTROLSEX_Init = init$A;
/**
 * INITCOMMONCONTROLSEX structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/commctrl/nf-commctrl-initcommoncontrolsex
 */
function INITCOMMONCONTROLSEX_Factory() {
    return genStruct(init$A, key$A, ptr$A, ['dwSize']);
}

const key$z = 'FILETIME';
const ptr$z = `${key$z}*`;
const init$z = {
    dwLowDateTime: DWORD,
    dwHighDateTime: DWORD,
};
const LPFILETIME = ptr$z;
const LPFILETIME_Name = key$z;
const FILETIME_Init = init$z;
/**
 * FILETIME structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime
 */
function FILETIME_Factory() {
    return genStruct(init$z, key$z, ptr$z);
}

const key$y = 'SYSTEMTIME';
const ptr$y = `${key$y}*`;
const init$y = {
    wYear: WORD,
    wMonth: WORD,
    wDayOfWeek: WORD,
    wDay: WORD,
    wHour: WORD,
    wMinute: WORD,
    wSecond: WORD,
    wMilliseconds: WORD,
};
const LPSYSTEMTIME = ptr$y;
const SYSTEMTIME_Name = key$y;
const SYSTEMTIME_Init = init$y;
/**
 * SYSTEMTIME structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-systemtime
 */
function SYSTEMTIME_Factory() {
    return genStruct(init$y, key$y, ptr$y);
}

const key$x = 'POINT';
const ptr$x = `${key$x}*`;
const init$x = {
    x: LONG,
    y: LONG,
};
const LPPOINT = ptr$x;
const POINT_Name = key$x;
const POINT_Init = init$x;
/**
 * POINT structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/windef/ns-windef-point
 */
function POINT_Factory() {
    return genStruct(init$x, key$x, ptr$x);
}

const key$w = 'RECT';
const ptr$w = `${key$w}*`;
const init$w = {
    left: LONG,
    top: LONG,
    right: LONG,
    bottom: LONG,
};
const LPRECT = ptr$w;
const RECT_Name = key$w;
const RECT_Init = init$w;
/**
 * RECT structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/windef/ns-windef-RECT
 */
function RECT_Factory() {
    return genStruct(init$w, key$w, ptr$w);
}

const key$v = 'DEVMODEW';
const ptr$v = `${key$v}*`;
const init$v = {
    dmDeviceName: genFixedInt16Array(32),
    dmSpecVersion: WORD,
    dmDriverVersion: WORD,
    dmSize: WORD,
    dmDriverExtra: WORD,
    dmFields: DWORD,
    u1: {
        s1: {
            dmOrientation: SHORT,
            dmPaperSize: SHORT,
            dmPaperLength: SHORT,
            dmPaperWidth: SHORT,
            dmScale: SHORT,
            dmCopies: SHORT,
            dmDefaultSource: SHORT,
            dmPrintQuality: SHORT,
        },
        dmPosition: POINT_Factory,
        s2: {
            dmPosition: POINT_Factory,
            dmDisplayOrientation: DWORD,
            dmDisplayFixedOutput: DWORD,
        },
    },
    dmColor: SHORT,
    dmDuplex: SHORT,
    dmYResolution: SHORT,
    dmTTOption: SHORT,
    dmCollate: SHORT,
    dmFormName: genFixedInt16Array(32),
    dmLogPixels: WORD,
    dmBitsPerPel: DWORD,
    dmPelsWidth: DWORD,
    dmPelsHeight: DWORD,
    u2: {
        dmDisplayFlags: DWORD,
        dmNup: DWORD,
    },
    dmDisplayFrequency: DWORD,
    dmICMMethod: DWORD,
    dmICMIntent: DWORD,
    dmMediaType: DWORD,
    dmDitherType: DWORD,
    dmReserved1: DWORD,
    dmReserved2: DWORD,
    dmPanningWidth: DWORD,
    dmPanningHeight: DWORD,
};
const LPDEVMODEW = ptr$v;
const DEVMODEW_Name = key$v;
const DEVMODEW_Init = init$v;
/**
 * DEVMODEW structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-devmodew
 */
function DEVMODEW_Factory() {
    return genStruct(init$v, key$v, ptr$v, ['dmSize']);
}

const key$u = 'DISPLAY_DEVICEW';
const ptr$u = `${key$u}*`;
const init$u = {
    cb: DWORD,
    DeviceName: genFixedInt16Array(32),
    DeviceString: genFixedInt16Array(128),
    StateFlags: DWORD,
    DeviceID: genFixedInt16Array(128),
    DeviceKey: genFixedInt16Array(128),
};
const LPDISPLAY_DEVICEW = ptr$u;
const DISPLAY_DEVICEW_Name = key$u;
const DISPLAY_DEVICEW_Init = init$u;
/**
 * DISPLAY_DEVICEW structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-display_devicew
 */
function DISPLAY_DEVICEW_Factory() {
    return genStruct(init$u, key$u, ptr$u, ['cb']);
}

const key$t = 'DOC_INFO_1';
const ptr$t = `${key$t}*`;
const init$t = {
    pDocName: WString,
    pOutputFile: WString,
    pDatatype: WString,
};
const LPDOC_INFO_1 = ptr$t;
const DOC_INFO_1_Name = key$t;
const DOC_INFO_1_Init = init$t;
/**
 * DOC_INFO_1 structure,
 * Describes a document that will be printed.
 * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/doc-info-1
 */
function DOC_INFO_1_Factory() {
    return genStruct(init$t, key$t, ptr$t);
}

const key$s = 'JOB_INFO_1';
const ptr$s = `${key$s}*`;
const init$s = {
    JobId: DWORD,
    pPrinterName: LPTSTR,
    pMachineName: LPTSTR,
    pUserName: LPTSTR,
    pDocument: LPTSTR,
    pDatatype: LPTSTR,
    pStatus: LPTSTR,
    Status: DWORD,
    Priority: DWORD,
    Position: DWORD,
    TotalPages: DWORD,
    PagesPrinted: DWORD,
    Submitted: SYSTEMTIME_Factory,
};
const PJOB_INFO_1 = ptr$s;
const JOB_INFO_1_Name = key$s;
const JOB_INFO_1_Init = init$s;
/**
 * JOB_INFO_1 structure,
 * The JOB_INFO_1 structure specifies print-job information such as the job-identifier value
 * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/job-info-1
 */
function JOB_INFO_1_Factory() {
    return genStruct(init$s, key$s, ptr$s);
}

const key$r = 'PRINTER_DEFAULTS';
const ptr$r = `${key$r}*`;
const init$r = {
    pDatatype: LPTSTR,
    pDevMode: DEVMODEW_Factory,
    DesiredAccess: ACCESS_MASK,
};
const PPRINTER_DEFAULTS = ptr$r;
const PRINTER_DEFAULTS_Name = key$r;
const PRINTER_DEFAULTS_Init = init$r;
/**
 * PRINTER_DEFAULTS structure,
 * Specifies the default data type, environment, initialization data, and access rights for a printer.
 * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/printer-defaults
 */
function PRINTER_DEFAULTS_Factory() {
    return genStruct(init$r, key$r, ptr$r);
}

const key$q = 'PRINTER_INFO_1';
const ptr$q = `${key$q}*`;
const init$q = {
    Flags: DWORD,
    pDescription: WString,
    pName: WString,
    pComment: WString,
};
const PPRINTER_INFO_1 = ptr$q;
const PRINTER_INFO_1_Name = key$q;
const PRINTER_INFO_1_Init = init$q;
/**
 * PRINTER_INFO_1 structure,
 * Specifies general printer information
 * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/PRINTER-INFO-1
 */
function PRINTER_INFO_1_Factory() {
    return genStruct(init$q, key$q, ptr$q);
}

const key$p = 'PRINTER_INFO_4';
const ptr$p = `${key$p}*`;
const init$p = {
    pPrinterName: WString,
    pServerName: WString,
    Attributes: DWORD,
};
const PPRINTER_INFO_4 = ptr$p;
const PRINTER_INFO_4_Name = key$p;
const PRINTER_INFO_4_Init = init$p;
/**
 * PRINTER_INFO_4 structure,
 * Specifies general printer information
 * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/PRINTER-INFO-4
 * @description The structure can be used to retrieve minimal printer information on a call to EnumPrinters.
 *  Such a call is a fast and easy way to retrieve the names and attributes of all locally installed printers
 *  on a system and all remote printer connections that a user has established.
 */
function PRINTER_INFO_4_Factory() {
    return genStruct(init$p, key$p, ptr$p);
}

const key$o = 'PRINTER_INFO_5';
const ptr$o = `${key$o}*`;
const init$o = {
    pPrinterName: WString,
    pPortName: WString,
    Attributes: DWORD,
    DeviceNotSelectedTimeout: DWORD,
    TransmissionRetryTimeout: DWORD,
};
const PPRINTER_INFO_5 = ptr$o;
const PRINTER_INFO_5_Name = key$o;
const PRINTER_INFO_5_Init = init$o;
/**
 * PRINTER_INFO_5 structure,
 * structure specifies detailed printer information.
 * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/PRINTER-INFO-5
 */
function PRINTER_INFO_5_Factory() {
    return genStruct(init$o, key$o, ptr$o);
}

const key$n = 'PRINTER_INFO_8';
const ptr$n = `${key$n}*`;
const init$n = {
    pDevMode: DEVMODEW_Factory,
};
const PPRINTER_INFO_8 = ptr$n;
const PRINTER_INFO_8_Name = key$n;
const PRINTER_INFO_8_Init = init$n;
/**
 * PRINTER_INFO_8 structure,
 * specifies the global default printer settings.
 * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/PRINTER-INFO-8
 */
function PRINTER_INFO_8_Factory() {
    return genStruct(init$n, key$n, ptr$n);
}

const key$m = 'PRINTER_INFO_9';
const ptr$m = `${key$m}*`;
const init$m = {
    pDevMode: DEVMODEW_Factory,
};
const PPRINTER_INFO_9 = ptr$m;
const PRINTER_INFO_9_Name = key$m;
const PRINTER_INFO_9_Init = init$m;
/**
 * PRINTER_INFO_9 structure,
 * structure specifies the per-user default printer settings.
 * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/PRINTER-INFO-9
 */
function PRINTER_INFO_9_Factory() {
    return genStruct(init$m, key$m, ptr$m);
}

const key$l = 'PRINTPROCESSOR_INFO_1';
const ptr$l = `${key$l}*`;
const init$l = {
    pName: LPTSTR,
};
const PPRINTPROCESSOR_INFO_1 = ptr$l;
const PRINTPROCESSOR_INFO_1_Name = key$l;
const PRINTPROCESSOR_INFO_1_Init = init$l;
/**
 * PRINTPROCESSOR_INFO_1 structure,
 * Specifies the name of an installed print processor.
 * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/printprocessor-info-1
 */
function PRINTPROCESSOR_INFO_1_Factory() {
    return genStruct(init$l, key$l, ptr$l);
}

const key$k = 'PRINTER_INFO_6';
const ptr$k = `${key$k}*`;
const init$k = {
    dwStatus: DWORD,
};
const PPRINTER_INFO_6 = ptr$k;
const PRINTER_INFO_6_Name = key$k;
const PRINTER_INFO_6_Init = init$k;
/**
 * PRINTER_INFO_6 structure,
 * structure specifies detailed printer information.
 * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/PRINTER-INFO-6
 */
function PRINTER_INFO_6_Factory() {
    return genStruct(init$k, key$k, ptr$k);
}

const key$j = 'ALTTABINFO';
const ptr$j = `${key$j}*`;
const init$j = {
    cbSize: DWORD,
    cItems: INT,
    cColumns: INT,
    cRows: INT,
    iColFocus: INT,
    iRowFocus: INT,
    cxItem: INT,
    cyItem: INT,
    ptStart: POINT_Factory,
};
const LPALTTABINFO = ptr$j;
const ALTTABINFO_Name = key$j;
const ALTTABINFO_Init = init$j;
/**
 * ALTTABINFO structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-alttabinfo
 */
function ALTTABINFO_Factory() {
    return genStruct(init$j, key$j, ptr$j, ['cbSize']);
}

const key$i = 'COPYDATASTRUCT';
const ptr$i = `${key$i}*`;
const init$i = {
    dwData: ULONG_PTR,
    cbData: DWORD,
    lpData: PVOID,
};
const LPCOPYDATASTRUCT = ptr$i;
const COPYDATASTRUCT_Name = key$i;
const COPYDATASTRUCT_Init = init$i;
/**
 * COPYDATASTRUCT structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-copydatastruct
 */
function COPYDATASTRUCT_Factory() {
    return genStruct(init$i, key$i, ptr$i);
}

const key$h = 'FLASHWINFO';
const ptr$h = `${key$h}*`;
const init$h = {
    cbSize: UINT,
    hwnd: HWND,
    dwFlags: DWORD,
    uCount: UINT,
    dwTimeout: DWORD,
};
const PFLASHWINFO = ptr$h;
const FLASHWINFO_Name = key$h;
const FLASHWINFO_Init = init$h;
/**
 * FLASHWINFO structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-FLASHWINFO
 */
function FLASHWINFO_Factory() {
    return genStruct(init$h, key$h, ptr$h, ['cbSize']);
}

const key$g = 'HARDWAREINPUT';
const ptr$g = `${key$g}*`;
const init$g = {
    uMsg: UINT32,
    wParamL: UINT16,
    wParamH: UINT16,
};
const LPHARDWAREINPUT = ptr$g;
const HARDWAREINPUT_Name = key$g;
const HARDWAREINPUT_Init = init$g;
/**
 * HARDWAREINPUT structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-hardwareinput
 */
function HARDWAREINPUT_Factory() {
    return genStruct(init$g, key$g, ptr$g);
}

const key$f = 'KEYBDINPUT';
const ptr$f = `${key$f}*`;
const init$f = {
    wVk: UINT16,
    wScan: UINT16,
    dwFlags: UINT32,
    time: UINT32,
    dwExtraInfo: PUINT,
};
const LPKEYBDINPUT = ptr$f;
const KEYBDINPUT_Name = key$f;
const KEYBDINPUT_Init = init$f;
/**
 * KEYBDINPUT structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-keybdinput
 */
function KEYBDINPUT_Factory() {
    return genStruct(init$f, key$f, ptr$f);
}

const key$e = 'MOUSEINPUT';
const ptr$e = `${key$e}*`;
const init$e = {
    dx: LONG,
    dy: LONG,
    mouseData: UINT32,
    dwFlags: UINT32,
    time: UINT32,
    dwExtraInfo: PUINT,
};
const LPMOUSEINPUT = ptr$e;
const MOUSEINPUT_Name = key$e;
const MOUSEINPUT_Init = init$e;
/**
 * MOUSEINPUT structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-mouseinput
 */
function MOUSEINPUT_Factory() {
    return genStruct(init$e, key$e, ptr$e);
}

const key$d = 'INPUT';
const ptr$d = `${key$d}*`;
const init$d = {
    type: UINT32,
    u: {
        mi: MOUSEINPUT_Factory,
        ki: KEYBDINPUT_Factory,
        hi: HARDWAREINPUT_Factory,
    },
};
const LPINPUT = ptr$d;
const INPUT_Name = key$d;
const INPUT_Init = init$d;
/**
 * INPUT structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-input
 */
function INPUT_Factory() {
    return genStruct(init$d, key$d, ptr$d);
}
// export const INPUT = koffi.struct('INPUT', {
//   type: W.UINT32,
//   u: koffi.union({
//     mi: MOUSEINPUT,
//     ki: KEYBDINPUT,
//     hi: HARDWAREINPUT,
//   }),
// })

const key$c = 'MSG';
const ptr$c = `${key$c}*`;
const init$c = {
    hwnd: HWND,
    message: UINT,
    wParam: WPARAM,
    lParam: LPARAM,
    time: DWORD,
    pt: POINT_Factory,
    lPrivate: DWORD,
};
const LPMSG = ptr$c;
const MSG_Name = key$c;
const MSG_Init = init$c;
/**
 * MSG structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-msg
 */
function MSG_Factory() {
    return genStruct(init$c, key$c, ptr$c);
}

const key$b = 'RAWHID';
const ptr$b = `${key$b}*`;
const init$b = {
    dwSizeHid: DWORD,
    dwCount: DWORD,
    /** bRawData[1] */
    bRawData: BYTE,
};
const LPRAWHID = ptr$b;
const RAWHID_Name = key$b;
const RAWHID_Init = init$b;
/**
 * RAWHID structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-rawhid
 */
function RAWHID_Factory() {
    return genStruct(init$b, key$b, ptr$b);
}

const key$a = 'RAWINPUTHEADER';
const ptr$a = `${key$a}*`;
const init$a = {
    dwType: DWORD,
    dwSize: DWORD,
    hDevice: HANDLE,
    wParam: WPARAM,
};
const LPRAWINPUTHEADER = ptr$a;
const RAWINPUTHEADER_Name = key$a;
const RAWINPUTHEADER_Init = init$a;
/**
 * RAWINPUTHEADER structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-RAWINPUTHEADER
 */
function RAWINPUTHEADER_Factory() {
    return genStruct(init$a, key$a, ptr$a);
}

const key$9 = 'RAWKEYBOARD';
const ptr$9 = `${key$9}*`;
const init$9 = {
    MakeCode: USHORT,
    Flags: USHORT,
    Reserved: USHORT,
    VKey: USHORT,
    Message: UINT,
    ExtraInformation: ULONG,
};
const LPRAWKEYBOARD = ptr$9;
const RAWKEYBOARD_Name = key$9;
const RAWKEYBOARD_Init = init$9;
/**
 * RAWKEYBOARD structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-RAWKEYBOARD
 */
function RAWKEYBOARD_Factory() {
    return genStruct(init$9, key$9, ptr$9);
}

const key$8 = 'RAWMOUSE';
const ptr$8 = `${key$8}*`;
const init$8 = {
    usFlags: USHORT,
    u: {
        ulButtons: ULONG,
        s: {
            usButtonFlags: USHORT,
            usButtonData: USHORT,
        },
    },
    ulRawButtons: ULONG,
    lLastX: LONG,
    lLastY: LONG,
    ulExtraInformation: ULONG,
};
/**
 * RAWMOUSE structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-RAWMOUSE
 */
function RAWMOUSE_Factory() {
    return genStruct(init$8, key$8, ptr$8);
}
const LPRAWMOUSE = ptr$8;
const RAWMOUSE_Name = key$8;
const RAWMOUSE_Init = init$8;

const key$7 = 'RAWINPUT';
const ptr$7 = `${key$7}*`;
const init$7 = {
    header: RAWINPUTHEADER_Factory,
    u: {
        mouse: RAWMOUSE_Factory,
        keyboard: RAWKEYBOARD_Factory,
        hid: RAWHID_Factory,
    },
};
const LPRAWINPUT = ptr$7;
const RAWINPUT_Name = key$7;
const RAWINPUT_Init = init$7;
/**
 * RAWINPUT structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-rawinput
 */
function RAWINPUT_Factory() {
    return genStruct(init$7, key$7, ptr$7);
}

const key$6 = 'RAWINPUTDEVICELIST';
const ptr$6 = `${key$6}*`;
const init$6 = {
    hDevice: HANDLE,
    dwType: DWORD,
};
const LPRAWINPUTDEVICELIST = ptr$6;
const RAWINPUTDEVICELIST_Name = key$6;
const RAWINPUTDEVICELIST_Init = init$6;
/**
 * RAWINPUTDEVICELIST structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-RAWINPUTDEVICELIST
 */
function RAWINPUTDEVICELIST_Factory() {
    return genStruct(init$6, key$6, ptr$6);
}

const key$5 = 'RID_DEVICE_INFO_HID';
const ptr$5 = `${key$5}*`;
const init$5 = {
    dwVendorId: DWORD,
    dwProductId: DWORD,
    dwVersionNumber: DWORD,
    usUsagePage: USHORT,
    usUsage: USHORT,
};
const PRID_DEVICE_INFO_HID = ptr$5;
const RID_DEVICE_INFO_HID_Name = key$5;
const RID_DEVICE_INFO_HID_Init = init$5;
/**
 * RID_DEVICE_INFO_HID structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-RID_DEVICE_INFO_HID
 */
function RID_DEVICE_INFO_HID_Factory() {
    return genStruct(init$5, key$5, ptr$5);
}

const key$4 = 'RID_DEVICE_INFO_KEYBOARD';
const ptr$4 = `${key$4}*`;
const init$4 = {
    dwType: DWORD,
    dwSubType: DWORD,
    dwKeyboardMode: DWORD,
    dwNumberOfFunctionKeys: DWORD,
    dwNumberOfIndicators: DWORD,
    dwNumberOfKeysTotal: DWORD,
};
const PRID_DEVICE_INFO_KEYBOARD = ptr$4;
const RID_DEVICE_INFO_KEYBOARD_Name = key$4;
const RID_DEVICE_INFO_KEYBOARD_Init = init$4;
/**
 * RID_DEVICE_INFO_KEYBOARD structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-RID_DEVICE_INFO_KEYBOARD
 */
function RID_DEVICE_INFO_KEYBOARD_Factory() {
    return genStruct(init$4, key$4, ptr$4);
}

const key$3 = 'RID_DEVICE_INFO_MOUSE';
const ptr$3 = `${key$3}*`;
const init$3 = {
    dwId: DWORD,
    dwNumberOfButtons: DWORD,
    dwSampleRate: DWORD,
    fHasHorizontalWheel: BOOL,
};
const PRID_DEVICE_INFO_MOUSE = ptr$3;
const RID_DEVICE_INFO_MOUSE_Name = key$3;
const RID_DEVICE_INFO_MOUSE_Init = init$3;
/**
 * RID_DEVICE_INFO_MOUSE structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-RID_DEVICE_INFO_MOUSE
 */
function RID_DEVICE_INFO_MOUSE_Factory() {
    return genStruct(init$3, key$3, ptr$3);
}

const key$2 = 'RID_DEVICE_INFO';
const ptr$2 = `${key$2}*`;
const init$2 = {
    cbSize: DWORD,
    dwType: DWORD,
    u: {
        mouse: RID_DEVICE_INFO_MOUSE_Factory,
        keyboard: RID_DEVICE_INFO_KEYBOARD_Factory,
        hid: RID_DEVICE_INFO_HID_Factory,
    },
};
const LPRID_DEVICE_INFO = ptr$2;
const RID_DEVICE_INFO_Name = key$2;
const RID_DEVICE_INFO_Init = init$2;
/**
 * RID_DEVICE_INFO structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-RID_DEVICE_INFO
 */
function RID_DEVICE_INFO_Factory() {
    return genStruct(init$2, key$2, ptr$2, ['cbSize']);
}

const key$1 = 'WNDCLASSEXW';
const ptr$1 = `${key$1}*`;
const init$1 = {
    cbSize: UINT,
    style: UINT,
    lpfnWndProc: WNDPROC,
    cbClsExtra: INT,
    cbWndExtra: INT,
    hInstance: HINSTANCE,
    hIcon: HICON,
    hCursor: HCURSOR,
    hbrBackground: HBRUSH,
    lpszMenuName: WString,
    lpszClassName: WString,
    hIconSm: HICON,
};
const LPWNDCLASSEXW = ptr$1;
const WNDCLASSEXW_Name = key$1;
const WNDCLASSEXW_Init = init$1;
/**
 * WNDCLASSEXW structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassexw
 */
function WNDCLASSEXW_Factory() {
    return genStruct(init$1, key$1, ptr$1, ['cbSize']);
}

const key = 'WINDOWINFO';
const ptr = `${key}*`;
const init = {
    cbSize: DWORD,
    rcWindow: RECT_Factory,
    rcClient: RECT_Factory,
    dwStyle: DWORD,
    dwExStyle: DWORD,
    dwWindowStatus: DWORD,
    cxWindowBorders: UINT,
    cyWindowBorders: UINT,
    atomWindowType: ATOM,
    wCreatorVersion: WORD,
};
const LPWINDOWINFO = ptr;
const WINDOWINFO_Name = key;
const WINDOWINFO_Init = init;
/**
 * WINDOWINFO structure
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-WINDOWINFO
 */
function WINDOWINFO_Factory() {
    return genStruct(init, key, ptr, ['cbSize']);
}

var Structs = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ALTTABINFO_Factory: ALTTABINFO_Factory,
    ALTTABINFO_Init: ALTTABINFO_Init,
    ALTTABINFO_Name: ALTTABINFO_Name,
    COPYDATASTRUCT_Factory: COPYDATASTRUCT_Factory,
    COPYDATASTRUCT_Init: COPYDATASTRUCT_Init,
    COPYDATASTRUCT_Name: COPYDATASTRUCT_Name,
    DEVMODEW_Factory: DEVMODEW_Factory,
    DEVMODEW_Init: DEVMODEW_Init,
    DEVMODEW_Name: DEVMODEW_Name,
    DISPLAY_DEVICEW_Factory: DISPLAY_DEVICEW_Factory,
    DISPLAY_DEVICEW_Init: DISPLAY_DEVICEW_Init,
    DISPLAY_DEVICEW_Name: DISPLAY_DEVICEW_Name,
    DOC_INFO_1_Factory: DOC_INFO_1_Factory,
    DOC_INFO_1_Init: DOC_INFO_1_Init,
    DOC_INFO_1_Name: DOC_INFO_1_Name,
    FILETIME_Factory: FILETIME_Factory,
    FILETIME_Init: FILETIME_Init,
    FLASHWINFO_Factory: FLASHWINFO_Factory,
    FLASHWINFO_Init: FLASHWINFO_Init,
    FLASHWINFO_Name: FLASHWINFO_Name,
    HARDWAREINPUT_Factory: HARDWAREINPUT_Factory,
    HARDWAREINPUT_Init: HARDWAREINPUT_Init,
    HARDWAREINPUT_Name: HARDWAREINPUT_Name,
    INITCOMMONCONTROLSEX_Factory: INITCOMMONCONTROLSEX_Factory,
    INITCOMMONCONTROLSEX_Init: INITCOMMONCONTROLSEX_Init,
    INITCOMMONCONTROLSEX_Name: INITCOMMONCONTROLSEX_Name,
    INPUT_Factory: INPUT_Factory,
    INPUT_Init: INPUT_Init,
    INPUT_Name: INPUT_Name,
    JOB_INFO_1_Factory: JOB_INFO_1_Factory,
    JOB_INFO_1_Init: JOB_INFO_1_Init,
    JOB_INFO_1_Name: JOB_INFO_1_Name,
    KEYBDINPUT_Factory: KEYBDINPUT_Factory,
    KEYBDINPUT_Init: KEYBDINPUT_Init,
    KEYBDINPUT_Name: KEYBDINPUT_Name,
    LPALTTABINFO: LPALTTABINFO,
    LPCOPYDATASTRUCT: LPCOPYDATASTRUCT,
    LPDEVMODEW: LPDEVMODEW,
    LPDISPLAY_DEVICEW: LPDISPLAY_DEVICEW,
    LPDOC_INFO_1: LPDOC_INFO_1,
    LPFILETIME: LPFILETIME,
    LPFILETIME_Name: LPFILETIME_Name,
    LPHARDWAREINPUT: LPHARDWAREINPUT,
    LPINITCOMMONCONTROLSEX: LPINITCOMMONCONTROLSEX,
    LPINPUT: LPINPUT,
    LPKEYBDINPUT: LPKEYBDINPUT,
    LPMOUSEINPUT: LPMOUSEINPUT,
    LPMSG: LPMSG,
    LPPOINT: LPPOINT,
    LPRAWHID: LPRAWHID,
    LPRAWINPUT: LPRAWINPUT,
    LPRAWINPUTDEVICELIST: LPRAWINPUTDEVICELIST,
    LPRAWINPUTHEADER: LPRAWINPUTHEADER,
    LPRAWKEYBOARD: LPRAWKEYBOARD,
    LPRAWMOUSE: LPRAWMOUSE,
    LPRECT: LPRECT,
    LPRID_DEVICE_INFO: LPRID_DEVICE_INFO,
    LPSYSTEMTIME: LPSYSTEMTIME,
    LPWINDOWINFO: LPWINDOWINFO,
    LPWNDCLASSEXW: LPWNDCLASSEXW,
    MOUSEINPUT_Factory: MOUSEINPUT_Factory,
    MOUSEINPUT_Init: MOUSEINPUT_Init,
    MOUSEINPUT_Name: MOUSEINPUT_Name,
    MSG_Factory: MSG_Factory,
    MSG_Init: MSG_Init,
    MSG_Name: MSG_Name,
    PFLASHWINFO: PFLASHWINFO,
    PJOB_INFO_1: PJOB_INFO_1,
    POINT_Factory: POINT_Factory,
    POINT_Init: POINT_Init,
    POINT_Name: POINT_Name,
    PPRINTER_DEFAULTS: PPRINTER_DEFAULTS,
    PPRINTER_INFO_1: PPRINTER_INFO_1,
    PPRINTER_INFO_4: PPRINTER_INFO_4,
    PPRINTER_INFO_5: PPRINTER_INFO_5,
    PPRINTER_INFO_6: PPRINTER_INFO_6,
    PPRINTER_INFO_8: PPRINTER_INFO_8,
    PPRINTER_INFO_9: PPRINTER_INFO_9,
    PPRINTPROCESSOR_INFO_1: PPRINTPROCESSOR_INFO_1,
    PRID_DEVICE_INFO_HID: PRID_DEVICE_INFO_HID,
    PRID_DEVICE_INFO_KEYBOARD: PRID_DEVICE_INFO_KEYBOARD,
    PRID_DEVICE_INFO_MOUSE: PRID_DEVICE_INFO_MOUSE,
    PRINTER_DEFAULTS_Factory: PRINTER_DEFAULTS_Factory,
    PRINTER_DEFAULTS_Init: PRINTER_DEFAULTS_Init,
    PRINTER_DEFAULTS_Name: PRINTER_DEFAULTS_Name,
    PRINTER_INFO_1_Factory: PRINTER_INFO_1_Factory,
    PRINTER_INFO_1_Init: PRINTER_INFO_1_Init,
    PRINTER_INFO_1_Name: PRINTER_INFO_1_Name,
    PRINTER_INFO_4_Factory: PRINTER_INFO_4_Factory,
    PRINTER_INFO_4_Init: PRINTER_INFO_4_Init,
    PRINTER_INFO_4_Name: PRINTER_INFO_4_Name,
    PRINTER_INFO_5_Factory: PRINTER_INFO_5_Factory,
    PRINTER_INFO_5_Init: PRINTER_INFO_5_Init,
    PRINTER_INFO_5_Name: PRINTER_INFO_5_Name,
    PRINTER_INFO_6_Factory: PRINTER_INFO_6_Factory,
    PRINTER_INFO_6_Init: PRINTER_INFO_6_Init,
    PRINTER_INFO_6_Name: PRINTER_INFO_6_Name,
    PRINTER_INFO_8_Factory: PRINTER_INFO_8_Factory,
    PRINTER_INFO_8_Init: PRINTER_INFO_8_Init,
    PRINTER_INFO_8_Name: PRINTER_INFO_8_Name,
    PRINTER_INFO_9_Factory: PRINTER_INFO_9_Factory,
    PRINTER_INFO_9_Init: PRINTER_INFO_9_Init,
    PRINTER_INFO_9_Name: PRINTER_INFO_9_Name,
    PRINTPROCESSOR_INFO_1_Factory: PRINTPROCESSOR_INFO_1_Factory,
    PRINTPROCESSOR_INFO_1_Init: PRINTPROCESSOR_INFO_1_Init,
    PRINTPROCESSOR_INFO_1_Name: PRINTPROCESSOR_INFO_1_Name,
    RAWHID_Factory: RAWHID_Factory,
    RAWHID_Init: RAWHID_Init,
    RAWHID_Name: RAWHID_Name,
    RAWINPUTDEVICELIST_Factory: RAWINPUTDEVICELIST_Factory,
    RAWINPUTDEVICELIST_Init: RAWINPUTDEVICELIST_Init,
    RAWINPUTDEVICELIST_Name: RAWINPUTDEVICELIST_Name,
    RAWINPUTHEADER_Factory: RAWINPUTHEADER_Factory,
    RAWINPUTHEADER_Init: RAWINPUTHEADER_Init,
    RAWINPUTHEADER_Name: RAWINPUTHEADER_Name,
    RAWINPUT_Factory: RAWINPUT_Factory,
    RAWINPUT_Init: RAWINPUT_Init,
    RAWINPUT_Name: RAWINPUT_Name,
    RAWKEYBOARD_Factory: RAWKEYBOARD_Factory,
    RAWKEYBOARD_Init: RAWKEYBOARD_Init,
    RAWKEYBOARD_Name: RAWKEYBOARD_Name,
    RAWMOUSE_Factory: RAWMOUSE_Factory,
    RAWMOUSE_Init: RAWMOUSE_Init,
    RAWMOUSE_Name: RAWMOUSE_Name,
    RECT_Factory: RECT_Factory,
    RECT_Init: RECT_Init,
    RECT_Name: RECT_Name,
    RID_DEVICE_INFO_Factory: RID_DEVICE_INFO_Factory,
    RID_DEVICE_INFO_HID_Factory: RID_DEVICE_INFO_HID_Factory,
    RID_DEVICE_INFO_HID_Init: RID_DEVICE_INFO_HID_Init,
    RID_DEVICE_INFO_HID_Name: RID_DEVICE_INFO_HID_Name,
    RID_DEVICE_INFO_Init: RID_DEVICE_INFO_Init,
    RID_DEVICE_INFO_KEYBOARD_Factory: RID_DEVICE_INFO_KEYBOARD_Factory,
    RID_DEVICE_INFO_KEYBOARD_Init: RID_DEVICE_INFO_KEYBOARD_Init,
    RID_DEVICE_INFO_KEYBOARD_Name: RID_DEVICE_INFO_KEYBOARD_Name,
    RID_DEVICE_INFO_MOUSE_Factory: RID_DEVICE_INFO_MOUSE_Factory,
    RID_DEVICE_INFO_MOUSE_Init: RID_DEVICE_INFO_MOUSE_Init,
    RID_DEVICE_INFO_MOUSE_Name: RID_DEVICE_INFO_MOUSE_Name,
    RID_DEVICE_INFO_Name: RID_DEVICE_INFO_Name,
    SYSTEMTIME_Factory: SYSTEMTIME_Factory,
    SYSTEMTIME_Init: SYSTEMTIME_Init,
    SYSTEMTIME_Name: SYSTEMTIME_Name,
    WINDOWINFO_Factory: WINDOWINFO_Factory,
    WINDOWINFO_Init: WINDOWINFO_Init,
    WINDOWINFO_Name: WINDOWINFO_Name,
    WNDCLASSEXW_Factory: WNDCLASSEXW_Factory,
    WNDCLASSEXW_Init: WNDCLASSEXW_Init,
    WNDCLASSEXW_Name: WNDCLASSEXW_Name
});

const structFactoryMap = new Map();
if (!structFactoryMap.size) {
    Object.entries(Structs).forEach(([key, val]) => {
        if (typeof val === 'function') {
            structFactoryMap.set(key, val);
        }
    });
}

function expandFFIParamArray(input) {
    const res = [];
    const tmp = [];
    permute(input, 0, tmp, res);
    return res;
}
function permute(input, index, current, result) {
    if (index === input.length) {
        result.push(current);
        return;
    }
    const item = input[index];
    if (Array.isArray(item)) {
        const len = item.length;
        for (let i = 0; i < len; i += 1) {
            const tmp = item[i] ?? [];
            permute(input, index + 1, current.concat(tmp), result);
        }
    }
    else if (typeof item === 'string') {
        permute(input, index + 1, current.concat([item]), result);
    }
    else {
        throw new TypeError('invalid input');
    }
}

/* eslint-disable @typescript-eslint/no-unnecessary-type-parameters */
function createProxyMethod(options) {
    const { name, fnDefRetType, fnDefCallParams, lib } = options;
    const fnDefArgs = LoaderCache.getFnDefArgs(lib, name);
    assert(fnDefArgs.length > 0, 'fnDefArgs.length <= 0');
    const proxyFn = createKoffiFunctionLike({
        name,
        fnDefRetType,
        fnDefCallParams,
        funcSync: (...args) => createExecutionFn({ lib, name, args, type: 'sync' }),
        funcAsync: (...args) => createExecutionFn({ lib, name, args, type: 'async' }),
    });
    return proxyFn;
}
function createExecutionFn(options) {
    const { lib, name, args, type } = options;
    // args includes the last callback function for async call
    const pureArgs = type === 'async' ? args.slice(0, -1) : args;
    const fnDefArgs = LoaderCache.getFnDefArgs(lib, name);
    assert(fnDefArgs.length > 0, 'fnDefArgs.length <= 0');
    const runtimeDefArgs = multipleChoiceMapperProcessor(lib, name, pureArgs);
    const func = LoaderCache.getFuncByDefArgs(lib, name, runtimeDefArgs);
    assert(typeof func === 'function', `Function ${name} not found in cache, For:
  args: ${JSON.stringify(runtimeDefArgs)},
  fnDefCallParamsExpanded: ${JSON.stringify(fnDefArgs)} `);
    if (type === 'async') {
        return func.async(...args);
    }
    else {
        return func(...args);
    }
}
function multipleChoiceMapperProcessor(lib, fnName, runtimeArgs) {
    const fnDefCallParamsExpanded = LoaderCache.getFnDefArgs(lib, fnName);
    assert(fnDefCallParamsExpanded.length > 0, 'fnDefArgs.length <= 0');
    const mapperList = LoaderCache.getMultipleChoiceListMapperSet(lib, fnName);
    assert(mapperList && mapperList.size > 0, `multiple choice mapper not found for ${fnName}. It's may not be set.`);
    let matched;
    for (const mapper of mapperList) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const res = mapper(fnName, runtimeArgs, fnDefCallParamsExpanded);
        if (res) {
            assert(Array.isArray(res), `mapper must return an array`);
            assert(res.length > 0, `fnDefArgs not matched for ${fnName}.
  matchArgs: none,
  fnDefCallParamsExpanded: ${JSON.stringify(fnDefCallParamsExpanded)}`);
            matched = res;
            break;
        }
        // try next mapper if return undefined
    }
    assert(matched, `fnDefArgs not matched for ${fnName}.
  Check if missing function fnDefArgs, like
    EnumPrintersW: [D.BOOL,
    [
      D.DWORD,
      D.String,
      D.DWORD,
      [\`_Out_ \${S.PPRINTER_INFO_1}\`, \`_Out_ \${S.PPRINTER_INFO_4}\`], <== missing PPRINTER_INFO_5
      D.DWORD,
      D.LPDWORD,
      D.LPDWORD,
    ]],
  .
    `);
    return matched;
}
function createKoffiFunctionLike(options) {
    const { name, fnDefRetType, fnDefCallParams, funcSync, funcAsync } = options;
    const info = {
        name,
        fnDefRetType,
        fnDefCallParams,
    };
    Object.defineProperty(funcSync, 'info', {
        value: info,
    });
    Object.defineProperty(funcSync, 'async', {
        value: funcAsync,
    });
    return funcSync;
}
function updateMultipleChoiceMapperToCache(options) {
    const { lib, fnName, mapperSet, mapperList } = options;
    if (mapperList?.size) {
        LoaderCache.updateMultipleChoiceListMapper(lib, mapperList);
    }
    if (fnName && mapperSet?.size) {
        const set = LoaderCache.getMultipleChoiceListMapperSet(lib, fnName);
        if (set) {
            for (const mapper of mapperSet) {
                set.add(mapper);
            }
        }
        else {
            LoaderCache.updateMultipleChoiceListMapper(lib, new Map([[fnName, mapperSet]]));
        }
    }
}

process.arch.includes('64');
[
    exports.Def.float, exports.Def.int16, exports.Def.int32, exports.Def.int64, exports.Def.int8,
    exports.Def.uint16, exports.Def.uint32, exports.Def.uint64, exports.Def.uint8,
    exports.Def.long, exports.Def.ulong, exports.Def.longlong, exports.Def.ulonglong,
];
[
    exports.Def.boolPtr, exports.Def.bytePtr, exports.Def.charPtr, exports.Def.intPtr, exports.Def.int8Ptr,
    exports.Def.int16Ptr, exports.Def.int32Ptr, exports.Def.int64Ptr, exports.Def.floatPtr,
    exports.Def.longPtr, exports.Def.uintPtr, exports.Def.uint8Ptr,
    exports.Def.intPtrPtr, exports.Def.uint16Ptr, exports.Def.uint32Ptr, exports.Def.uint64Ptr,
    exports.Def.ulonglongPtr, exports.Def.voidPtr,
    exports.Def.uintPtrPtr, exports.Def.uint16PtrPtr, exports.Def.uint32PtrPtr, exports.Def.uint64PtrPtr,
    exports.Def.ulonglongPtrPtr, exports.Def.voidPtrPtr,
];
// #region loadIKoffiLibAndBindProperties
function loadIKoffiLib(libName) {
    const lib = ffi.load(libName);
    assert(lib, `load library ${libName} failed`);
    LoaderCache.setLibByName(libName, lib);
    return lib;
}
function bindFLibExtMethods(libName, lib, inst) {
    assert(lib, `load library undefined`);
    if (typeof inst.unload === 'undefined') {
        Object.defineProperty(inst, 'unload', {
            enumerable: false,
            value: () => {
                LoaderCache.removeLibByName(libName);
                lib.unload();
            },
        });
    }
    if (typeof inst.updateMultipleChoiceMapper === 'undefined') {
        Object.defineProperty(inst, 'updateMultipleChoiceMapper', {
            enumerable: false,
            value: function (opts2) {
                updateMultipleChoiceMapperToCache({
                    ...opts2,
                    lib: this,
                });
            }.bind(lib),
        });
    }
}
// #region bindMethodsFromFuncDefList
function bindMethodsFromFuncDefList(options) {
    const { lib, inst, loadOptions, funcDefList, multipleChoiceMapperList: multipleChoiceMapper } = options;
    for (const [name, params] of funcDefList) {
        const funcs = registerFunction({
            lib,
            fnName: name,
            fnFullParams: params,
            /* c8 ignore next */
            convention: loadOptions.convention ?? exports.CallingConvention.Cdecl,
            forceRegister: !!loadOptions.forceRegister,
        });
        const { size } = funcs;
        if (size === 1) {
            for (const [, fn] of funcs.entries()) {
                bindMethod(inst, name, fn);
            }
        }
        else if (size > 1) {
            if (!multipleChoiceMapper) {
                console.info(`multipleChoiceMapper should be set and be a function when multiple choice used.
      Syntax: (fnName: string, params: string[]) => string[]
      const user32 = load({
        dll: 'user32.dll',
        dllFuncs: defWin32,
        multipleChoiceMapperList: multipleChoiceMapperList
      })
      // OR
      const user32 = load({
        dll: 'user32.dll',
        dllFuncs: defWin32,
      })
      user32.updateMultipleChoiceMapper({ mapperList: mapperList })
        `);
            }
            const fn = createProxyMethod({
                lib,
                name,
                fnDefRetType: params[0],
                fnDefCallParams: params[1],
            });
            bindMethod(inst, name, fn);
        }
    }
}
function bindMethod(inst, name, fn) {
    const nameSync = name;
    if (typeof inst[nameSync] === 'undefined') {
        Object.defineProperty(inst, nameSync, {
            enumerable: true,
            value: fn,
        });
    }
    const nameAsync = `${name}_Async`;
    if (typeof inst[nameAsync] === 'undefined') {
        Object.defineProperty(inst, nameAsync, {
            enumerable: true,
            value: (...args) => callFnAsync(fn, args),
        });
    }
}
function callFnAsync(fn, args) {
    return new Promise((done, reject) => {
        const asyncCallback = (err, result) => {
            if (err) {
                reject(err);
                return;
            }
            done(result);
        };
        fn.async(...args, asyncCallback);
    });
}
function parse_settings(options) {
    const opts = {
        ...loadOptionsDefault,
        ...options,
    };
    return opts;
}
// #region createStructFromFuncDefList
function createStructFromFuncDefList(input) {
    const structFactories = prepareStructFromFuncDefList(input);
    structFactories.forEach((factory) => {
        factory();
    });
}
function prepareStructFromFuncDefList(input) {
    const fns = new Set();
    for (const [name, params] of input) {
        try {
            const p2 = expandFFIParamArray(params[1]);
            p2.forEach((args) => {
                const structSet = retrieveStructFactoryFromParams(args);
                if (structSet.size) {
                    structSet.forEach((fn) => {
                        fns.add(fn);
                    });
                }
            });
        }
        catch (ex) {
            assert(ex instanceof Error);
            const msg = `Failed to create struct for function: ${name}, you may need to create it manually.
      Error: ${ex.message}`;
            throw new Error(msg, { cause: ex });
        }
    }
    return fns;
}
function retrieveStructFactoryFromParams(params) {
    const fns = new Set();
    const structNames = retrieveStructTypeStringFromParams(params);
    if (!structNames.length) {
        return fns;
    }
    const failed = [];
    structNames.forEach((key) => {
        const factoryName = `${key}_Factory`;
        const fn = structFactoryMap.get(factoryName);
        if (fn) {
            fns.add(fn);
        }
        else {
            failed.push(key);
        }
    });
    if (failed.length) {
        throw new Error(`Failed to find struct factory for: ${failed.join(', ')}`);
    }
    return fns;
}
const DefValuesSet = new Set(Object.values(exports.Def));
// @ts-expect-error
DefValuesSet.add('char');
function retrieveStructTypeStringFromParams(params) {
    const ret = [];
    // '_Inout_ POINT*' or 'POINT *' or 'POINT*'
    const regex = /\b(\w+)\s?\*$/u;
    params.map((val) => {
        const match = regex.exec(val);
        const key = match?.[1]?.trim();
        if (key) {
            // if Def contains key, then skip
            // @ts-expect-error
            if (DefValuesSet.has(key)) {
                return;
            }
            ret.push(key);
        }
    });
    return ret;
}
// #region registerFunction
/**
 * @note do not call it directly, use `load()` instead!
 *  Case of making sure the library is loaded only once
 */
function registerFunction(options) {
    const { lib, fnName, fnFullParams: params, convention = exports.CallingConvention.Stdcall } = options;
    const cache = options.forceRegister ? null : LoaderCache.getRegisteredFuncMap(lib, fnName);
    if (cache?.size) {
        return cache;
    }
    const map = new Map();
    const { [0]: retType, [1]: args } = params;
    if (args.length === 0) {
        const params2 = [retType, []];
        // @ts-expect-error params2 is FnDefParams
        const func = _registerFunction({ lib, fnName: fnName, fnFullParams: params2, convention });
        map.set([], func);
        return map;
    }
    // 对于 args 每个成员检查是否为数组，是则迭代处理每个组合进行多次绑定方法
    const ps = expandFFIParamArray(args);
    ps.forEach((args2) => {
        const params2 = [retType, args2];
        // @ts-expect-error params2 is FnDefParams
        const func = _registerFunction({ lib, fnName: fnName, fnFullParams: params2, convention });
        map.set(args2, func);
    });
    return map;
}
function _registerFunction(options) {
    const { lib, fnName, fnFullParams, convention = exports.CallingConvention.Stdcall } = options;
    const { [0]: retType, [1]: args } = fnFullParams;
    assert(retType, 'retType is empty');
    assert(args, 'args is empty');
    // let func: KoffiFunction
    // const func = user32.func('GetCursorPos', 'int', [`_Out_ ${comb.pointer}`])
    // switch (convention) {
    //   case CallingConvention.Cdecl:
    //     func = lib.func(fnName, retType, args)
    //     break
    //   default:
    //     func = lib.func(convention, fnName, retType, args)
    // }
    const func = convention ? lib.func(convention, fnName, retType, args) : lib.func(fnName, retType, args);
    // console.log(func.info)
    LoaderCache.setRegisteredFuncToCache(lib, fnName, func, args);
    return func;
}
// #region SaveFnMultipleChoiceMapper
function saveFnMultipleChoiceMapperList(lib, fnMultipleChoiceMapperList) {
    assert(fnMultipleChoiceMapperList.size > 0, 'options.fnMultipleChoiceMapperList contains no item');
    LoaderCache.updateMultipleChoiceListMapper(lib, fnMultipleChoiceMapperList);
}
/*
export function prepareDllFile(file: string): string {

  if (file.startsWith('file://')) {
    return file
  }
  else if (file.startsWith('http://') || file.startsWith('https://')) {
    return file
  }
  else if (file.startsWith('/')) {
    return file
  }
  try {
    const stat = statSync(file)
    if (stat.isFile()) {
      return file
    }
  }
  catch {
    // void
  }

  const { HOME, WINDIR } = process.env
  assert(HOME, 'HOME is not defined')
  assert(WINDIR, 'WINDIR is not defined')

  const sys32dir = `${WINDIR}/system32`
  const path = `${sys32dir}/${file}`
  const target = `${HOME}/${file}.dll`

  const stat = statSync(path)
  if (! stat.isFile()) {
    throw new Error(`${file} is not found in path: "${path}"`)
  }

  try {
    const stat2 = statSync(target)
    if (stat2.isFile()) {
      return target
    }
    copyFileSync(path, target)
  }
  catch {
    copyFileSync(path, target)
  }

  return target
} */

function load(options) {
    const { dll, dllFuncs, usedFuncNames } = options;
    // const libName = dll.endsWith('.drv') ? prepareDllFile(dll) : dll
    const libName = dll;
    const opts = parse_settings(options);
    const funcDefListMap = processDefList(dllFuncs, usedFuncNames);
    assert(dllFuncs);
    const inst = {};
    let lib = LoaderCache.getLibByName(libName);
    if (!lib) {
        lib = loadIKoffiLib(libName);
    }
    if (options.multipleChoiceMapperList) {
        saveFnMultipleChoiceMapperList(lib, options.multipleChoiceMapperList);
    }
    if (opts.autoCreateStruct) {
        createStructFromFuncDefList(funcDefListMap);
    }
    bindMethodsFromFuncDefList({
        lib,
        inst,
        loadOptions: opts,
        funcDefList: funcDefListMap,
        multipleChoiceMapperList: opts.multipleChoiceMapperList,
        forceRegister: !!opts.forceRegister,
    });
    bindFLibExtMethods(libName, lib, inst);
    return inst;
}

function decodeInt16Array(input, length = -1) {
    assert(input, 'input must be an object');
    assert(typeof input.buffer === 'object', 'input.buffer must be an object');
    assert(typeof input.byteLength === 'number', 'input.byteLength must be a number');
    assert(typeof input.byteOffset === 'number', 'input.byteOffset must be a number');
    assert(typeof input.length === 'number', 'input.length must be a number');
    // const str = Buffer.from(input.buffer).toString('ucs2')
    // return str
    const str = ffi.decode(input, 'char16_t', length);
    return str || '';
}
/**
 * Convert a Buffer to string with UCS2 encoding, and remove the last '\0'.
 */
function ucsBufferToString(input, charNum = 0) {
    // read the last 2 bytes to check if it is '\0'
    const last = input.readUInt16LE(input.length - 2);
    if (charNum > 0) {
        const n2 = input.length / 2;
        const offset = Math.min(charNum, n2);
        const txt = input.toString('ucs2', 0, offset * 2);
        // return last === 0 && charNum >= n2 ? txt.slice(0, -1) : txt
        const ret = last === 0 ? txt.replace(/\0+$/u, '') : txt;
        return ret;
    }
    if (last === 0) { // remove the last '\0'
        return input.toString('ucs2').replace(/\0+$/u, '');
    }
    return input.toString('ucs2');
}
/**
 * Convert a string to Buffer with UCS2 encoding, and append a '\0' at the end.
 */
function ucsBufferFrom(str) {
    assert(typeof str === 'string', 'str must be a string ');
    return Buffer.from(str + '\0', 'ucs2');
}

exports.ffi = ffi;
exports.config = config;
exports.decodeInt16Array = decodeInt16Array;
exports.genComplexStruct = genComplexStruct;
exports.genFixedArray = genFixedArray;
exports.genFixedInt16Array = genFixedInt16Array;
exports.genStruct = genStruct;
exports.genUnion = genUnion;
exports.load = load;
exports.loadOptionsDefault = loadOptionsDefault;
exports.structFactoryMap = structFactoryMap;
exports.ucsBufferFrom = ucsBufferFrom;
exports.ucsBufferToString = ucsBufferToString;
//# sourceMappingURL=index.cjs.map
