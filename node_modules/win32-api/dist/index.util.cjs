/**
 * win32-api
 * FFI definitions of windows win32 api for node-ffi
 *
 * @version 26.1.1
 * @author waiting
 * @license MIT
 * @link https://waitingsong.github.io/node-win32-api
 */

'use strict';

var assert = require('node:assert');
var win32Def = require('win32-def');
var D = require('win32-def/def');
var S = require('win32-def/struct');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var D__namespace = /*#__PURE__*/_interopNamespaceDefault(D);
var S__namespace = /*#__PURE__*/_interopNamespaceDefault(S);

var DllNames;
(function (DllNames) {
    DllNames["comctl32"] = "comctl32";
    DllNames["gdi32"] = "gdi32";
    DllNames["kernel32"] = "kernel32";
    DllNames["ntdll"] = "ntdll";
    DllNames["spoolss"] = "spoolss";
    DllNames["user32"] = "user32";
    DllNames["winspool"] = "winspool.drv";
})(DllNames || (DllNames = {}));

class DefUser32_B {
    static BringWindowToTop = [D__namespace.BOOL, [D__namespace.HWND]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-broadcastsystemmessage */
    static BroadcastSystemMessage = [D__namespace.LRESULT, [D__namespace.DWORD, D__namespace.LPDWORD, D__namespace.UINT, D__namespace.WPARAM, D__namespace.LPARAM]];
}

class DefUser32_C extends DefUser32_B {
    /** https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-callwindowprocw */
    static CallWindowProcW = [D__namespace.LRESULT, [D__namespace.WNDPROC, D__namespace.HWND, D__namespace.UINT, D__namespace.WPARAM, D__namespace.LPARAM]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-changedisplaysettingsexw */
    static ChangeDisplaySettingsExW = [D__namespace.LONG, [D__namespace.WString, S__namespace.LPDEVMODEW, D__namespace.HWND, D__namespace.DWORD, D__namespace.LPVOID]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-clienttoscreen */
    static ClientToScreen = [D__namespace.BOOL, [D__namespace.HWND, `_Inout_ ${S__namespace.LPPOINT}`]];
    static CloseWindow = [D__namespace.BOOL, [D__namespace.HWND]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowexw */
    static CreateWindowExW = [
        D__namespace.HWND, [
            D__namespace.DWORD,
            D__namespace.WString,
            D__namespace.WString,
            D__namespace.DWORD,
            D__namespace.INT,
            D__namespace.INT,
            D__namespace.INT,
            D__namespace.INT,
            D__namespace.HWND,
            D__namespace.HMENU,
            D__namespace.HINSTANCE,
            D__namespace.LPVOID,
        ],
    ];
}
class DefUser32_D extends DefUser32_C {
    static DefWindowProcW = [D__namespace.LRESULT, [D__namespace.HWND, D__namespace.UINT, D__namespace.WPARAM, D__namespace.LPARAM]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroywindow */
    static DestroyWindow = [D__namespace.BOOL, [D__namespace.HWND]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dispatchmessagew */
    static DispatchMessageW = [D__namespace.LRESULT, [S__namespace.LPMSG]];
}

class DefUser32_E extends DefUser32_D {
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-enumchildwindows */
    static EnumChildWindows = [D__namespace.BOOL, [D__namespace.HWND, D__namespace.WNDENUMPROC, D__namespace.LPARAM]];
    /** https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-enumdisplaydevicesw */
    static EnumDisplayDevicesW = [D__namespace.BOOL, [D__namespace.LPCWSTR, D__namespace.DWORD, `_Inout_ ${S__namespace.LPDISPLAY_DEVICEW}`, D__namespace.DWORD]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-enumthreadwindows */
    static EnumThreadWindows = [D__namespace.BOOL, [D__namespace.DWORD, D__namespace.WNDENUMPROC, D__namespace.LPARAM]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-enumwindows */
    static EnumWindows = [D__namespace.BOOL, [D__namespace.WNDENUMPROC, D__namespace.LPARAM]];
}
class DefUser32_F extends DefUser32_E {
    /** https=//learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-findwindowexw */
    static FindWindowExW = [D__namespace.HWND, [D__namespace.HWND, D__namespace.HWND, D__namespace.LPCTSTR, D__namespace.LPCTSTR]];
    static FlashWindow = [D__namespace.BOOL, [D__namespace.HWND, D__namespace.BOOL]];
    static FlashWindowEx = [D__namespace.BOOL, [S__namespace.PFLASHWINFO]];
}

class DefUser32_G extends DefUser32_F {
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getancestor */
    static GetAncestor = [D__namespace.HWND, [D__namespace.HWND, D__namespace.UINT]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getalttabinfow */
    static GetAltTabInfoW = [D__namespace.BOOL, [D__namespace.HWND, D__namespace.INT, `_Inout_ ${S__namespace.LPALTTABINFO}`, `_Out_ ${D__namespace.LPWSTR}`, D__namespace.INT]];
    /**
     * Copies the caret's position to the specified POINT structure.
     * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getcaretpos
     */
    static GetCaretPos = [D__namespace.BOOL, [`_Out_ ${S__namespace.LPPOINT}`]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getclassinfoexw */
    static GetClassInfoExW = [D__namespace.BOOL, [D__namespace.HINSTANCE, [D__namespace.WString], `_Out_ ${S__namespace.LPWNDCLASSEXW}`]];
    /** https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-getclassnamew */
    static GetClassNameW = [D__namespace.INT, [D__namespace.HWND, D__namespace.LPTSTR, D__namespace.INT]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getcursorpos */
    static GetCursorPos = [D__namespace.BOOL, [`_Out_ ${S__namespace.LPPOINT}`]];
    /** https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-getclasslongptrw */
    static GetClassLongPtrW = [D__namespace.ULONG_PTR, [D__namespace.HWND, D__namespace.INT]];
    static GetForegroundWindow = [D__namespace.HWND, []];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessagew */
    static GetMessageW = [D__namespace.BOOL, [`_Out_ ${S__namespace.LPMSG}`, D__namespace.HWND, D__namespace.UINT, D__namespace.UINT]];
    static GetParent = [D__namespace.HWND, [D__namespace.HWND]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getrawinputdata */
    static GetRawInputData = [D__namespace.UINT, [S__namespace.LPRAWINPUT, D__namespace.UINT, D__namespace.LPVOID, `_Inout_ ${D__namespace.PUINT}`, D__namespace.UINT]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getrawinputdeviceinfow */
    static GetRawInputDeviceInfoW = [D__namespace.UINT, [D__namespace.HANDLE, D__namespace.UINT, `_Inout_ ${D__namespace.LPVOID}`, D__namespace.PUINT]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getrawinputdevicelist */
    static GetRawInputDeviceList = [D__namespace.INT, [`_Out_ ${S__namespace.LPRAWINPUTDEVICELIST}`, D__namespace.PUINT, D__namespace.UINT]];
    static GetTopWindow = [D__namespace.HWND, [D__namespace.HWND]];
    static GetWindow = [D__namespace.HWND, [D__namespace.HWND, D__namespace.UINT]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowinfo */
    static GetWindowInfo = [D__namespace.BOOL, [D__namespace.HWND, `_Inout_ ${S__namespace.LPWINDOWINFO}`]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlongw */
    static GetWindowLongW = [D__namespace.LONG, [D__namespace.HWND, D__namespace.INT]];
    /** only under x64 */
    static GetWindowLongPtrW = [D__namespace.LONG_PTR, [D__namespace.HWND, D__namespace.INT]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowrect */
    static GetWindowRect = [D__namespace.BOOL, [D__namespace.HWND, `_Out_ ${S__namespace.LPRECT}`]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowtextw */
    static GetWindowTextW = [D__namespace.INT, [D__namespace.HWND, D__namespace.LPTSTR, D__namespace.INT]];
    static GetWindowThreadProcessId = [D__namespace.DWORD, [D__namespace.HWND, D__namespace.LPDWORD]];
}

class DefUser32_I extends DefUser32_G {
    static IsIconic = [D__namespace.BOOL, [D__namespace.HWND]];
    static IsWindowVisible = [D__namespace.BOOL, [D__namespace.HWND]];
}
class DefUser32_M extends DefUser32_I {
    static MonitorFromWindow = [D__namespace.HWND, [D__namespace.HANDLE, D__namespace.DWORD]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messageboxexw */
    static MessageBoxExW = [D__namespace.INT, [D__namespace.HWND, D__namespace.WString, D__namespace.WString, D__namespace.UINT, D__namespace.WORD]];
}

class DefUser32_P extends DefUser32_M {
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-peekmessagew */
    static PeekMessageW = [D__namespace.BOOL, [`_Out_ ${S__namespace.LPMSG}`, D__namespace.HWND, D__namespace.UINT, D__namespace.UINT, D__namespace.UINT]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postmessagew */
    static PostMessageW = [D__namespace.BOOL, [D__namespace.HWND, D__namespace.UINT, D__namespace.WPARAM, D__namespace.LPARAM]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-printwindow */
    static PrintWindow = [D__namespace.BOOL, [D__namespace.HWND, D__namespace.HDC, D__namespace.UINT]];
}
class DefUser32_R extends DefUser32_P {
    /** https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-registerclassexw */
    static RegisterClassExW = [D__namespace.ATOM, [S__namespace.LPWNDCLASSEXW]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerwindowmessagew */
    static RegisterWindowMessageW = [D__namespace.UINT, [D__namespace.LPCWSTR]];
}

class DefUser32_S extends DefUser32_R {
    /**
     * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-sendinput
     */
    static SendInput = [D__namespace.UINT, [D__namespace.UINT, S__namespace.LPINPUT, D__namespace.INT]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-sendmessagew */
    static SendMessageW = [D__namespace.LRESULT, [D__namespace.HWND, D__namespace.UINT, D__namespace.WPARAM, D__namespace.LPARAM]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-sendmessagetimeoutw */
    static SendMessageTimeoutW = [D__namespace.LRESULT, [D__namespace.HWND, D__namespace.UINT, D__namespace.WPARAM, D__namespace.LPARAM, D__namespace.UINT, D__namespace.UINT, D__namespace.DWORD_PTR]];
    static SetForegroundWindow = [D__namespace.BOOL, [D__namespace.HWND]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setparent */
    static SetParent = [D__namespace.HWND, [D__namespace.HWND, D__namespace.HWND]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowpos */
    static SetWindowPos = [D__namespace.BOOL, [D__namespace.HWND, D__namespace.HWND, D__namespace.INT, D__namespace.INT, D__namespace.INT, D__namespace.INT, D__namespace.UINT]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowtextw */
    static SetWindowTextW = [D__namespace.BOOL, [D__namespace.HWND, D__namespace.WString]];
    // @TODO WINEVENTPROC
    static SetWinEventHook = [D__namespace.HWINEVENTHOOK, [D__namespace.UINT, D__namespace.UINT, D__namespace.HMODULE, D__namespace.WINEVENTPROC, D__namespace.DWORD, D__namespace.DWORD, D__namespace.UINT]];
    static ShowWindow = [D__namespace.BOOL, [D__namespace.HWND, D__namespace.INT]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindowasync */
    static ShowWindowAsync = [D__namespace.BOOL, [D__namespace.HWND, D__namespace.INT]];
}

class DefUser32_T extends DefUser32_S {
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage */
    static TranslateMessage = [D__namespace.BOOL, [S__namespace.LPMSG]];
    /** https://learn.microsoft.com/en-us/windows/win32/winmsg/translatemessageex */
    static TranslateMessageEx = [D__namespace.BOOL, [S__namespace.LPMSG]];
}
class DefUser32_U extends DefUser32_T {
    static UnhookWinEvent = [D__namespace.BOOL, [D__namespace.HWINEVENTHOOK]];
    /** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-unregisterclassw */
    static UnregisterClassW = [D__namespace.BOOL, [D__namespace.WString, D__namespace.HINSTANCE]];
    static UpdateWindow = [D__namespace.BOOL, [D__namespace.HWND]];
}

class DefUser32 extends DefUser32_U {
}

const funcName$8 = 'GetClassInfoExW';
const GetClassInfoExW_mapper = (name, runtimeArgs, defParamsArray) => {
    if (name !== funcName$8) {
        return;
    }
    const lpszClass = runtimeArgs[1];
    for (const row of defParamsArray) {
        assert(Array.isArray(row));
        const defArg = row[1];
        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check
        switch (typeof lpszClass) {
            case 'string': {
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                if (defArg === D.WString) { // WString
                    return row;
                }
                break;
            }
            case 'object': {
                assert(lpszClass instanceof Buffer, 'Invalid lpszClass type, must Buffer if object');
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                if (defArg === D.WString) { // WString
                    return row;
                }
                break;
            }
            default:
                throw new Error(`Invalid lpszClass type: ${typeof lpszClass}`);
        }
    }
    // return [] // will throw Error
};

const multipleChoiceMapperList$1 = new Map();
const multipleChoiceMapperSet$1 = new Set();
multipleChoiceMapperList$1.set(funcName$8, multipleChoiceMapperSet$1);
multipleChoiceMapperSet$1.add(GetClassInfoExW_mapper);

const dllName$1 = DllNames.user32;
const load$1 = (fns) => win32Def.load({
    dll: dllName$1 + '.dll',
    dllFuncs: DefUser32,
    usedFuncNames: fns,
    multipleChoiceMapperList: multipleChoiceMapperList$1,
});

const fnName$2 = 'FindWindowExW';
const fnAsyncName$2 = 'FindWindowExW_Async';
/**
 * Retrieves a handle to a window whose class name and window name match the specified strings.
 * The function searches child windows, beginning with the one following the specified child window.
 * This function does not perform a case-sensitive search.
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-findwindowexw
 *
 * 检索其类名和窗口名称与指定字符串匹配的窗口的句柄。 函数搜索子窗口，从指定子窗口后面的子窗口开始。 此函数不执行区分大小写的搜索。
 * @link https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-findwindowexw
 */
async function FindWindowEx(hwndParent, hwndChildAfter, lpszClass, lpszWindow) {
    const lib = load$1([fnName$2]);
    const fn = lib[fnAsyncName$2];
    assert(typeof fn === 'function', `Function "${fnAsyncName$2}" not found`);
    const hwnd = await fn(hwndParent, hwndChildAfter, lpszClass, lpszWindow);
    return hwnd;
}

const fnName$1 = 'GetWindowTextW';
const fnAsyncName$1 = 'GetWindowTextW_Async';
/**
 * Retrieves a handle to a window whose class name and window name match the specified strings.
 * The function searches child windows, beginning with the one following the specified child window.
 * This function does not perform a case-sensitive search.
 * @link https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowtextw
 *
 * 检索其类名和窗口名称与指定字符串匹配的窗口的句柄。 函数搜索子窗口，从指定子窗口后面的子窗口开始。 此函数不执行区分大小写的搜索。
 * @link https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-getwindowtextw
 */
async function GetWindowText(hWnd, nMaxCount) {
    const lib = load$1([fnName$1]);
    const fn = lib[fnAsyncName$1];
    assert(typeof fn === 'function', `Function "${fnAsyncName$1}" not found`);
    const buf = Buffer.alloc(nMaxCount * 2);
    const resLength = await fn(hWnd, buf, nMaxCount);
    const len2 = Math.min(resLength, nMaxCount - 1);
    const title = win32Def.ucsBufferToString(buf, len2);
    return title || '';
}

/* c8 ignore start */
const fnName = 'MessageBoxExW';
const fnAsyncName = 'MessageBoxExW_Async';
/** https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messageboxexw */
async function MessageBox(options) {
    const { hWnd, lpText, lpCaption, uType, wLanguageId } = options;
    const lib = load$1([fnName]);
    const fn = lib[fnAsyncName];
    assert(typeof fn === 'function', `Function "${fnAsyncName}" not found`);
    const res = await fn(hWnd, lpText, lpCaption, uType, wLanguageId);
    return res;
}
/* c8 ignore stop */

class DefWinspool {
    static ClosePrinter = [D__namespace.BOOL, [D__namespace.HANDLE]];
    static EndDocPrinter = [D__namespace.BOOL, [D__namespace.HANDLE]];
    static EndPagePrinter = [D__namespace.BOOL, [D__namespace.HANDLE]];
    /**
     * Enumerates available printers, print servers, domains, or print providers.
     * using multipleChoice to accept payload `pPrinterEnum` depends on `Level`
     * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/enumprinters
     */
    static EnumPrintersW = [D__namespace.BOOL,
        [
            D__namespace.DWORD,
            D__namespace.WString,
            D__namespace.DWORD,
            `_Out_ ${D__namespace.LPBYTE}`,
            D__namespace.DWORD,
            D__namespace.LPDWORD,
            D__namespace.LPDWORD,
        ]];
    /**
     * Enumerates the print processors installed on the specified server.
     * @docs https://learn.microsoft.com/en-us/windows/win32/printdocs/enumprintprocessors
     */
    static EnumPrintProcessorsW = [D__namespace.BOOL, [D__namespace.LPTSTR, D__namespace.LPTSTR, D__namespace.DWORD, `_Out_ ${D__namespace.LPBYTE}`, D__namespace.DWORD, `_Out_ ${D__namespace.LPDWORD}`, `_Out_ ${D__namespace.LPDWORD}`]];
    /**
     * Enumerates the data types that a specified print processor supports.
     * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/enumprintprocessordatatypes
     */
    static EnumPrintProcessorDatatypesW = [D__namespace.BOOL, [D__namespace.LPTSTR, D__namespace.LPTSTR, D__namespace.DWORD, `_Out_ ${D__namespace.LPBYTE}`, D__namespace.DWORD, `_Out_ ${D__namespace.LPDWORD}`, `_Out_ ${D__namespace.LPDWORD}`]];
    /** https://learn.microsoft.com/en-us/windows/win32/printdocs/getdefaultprinter */
    static GetDefaultPrinterW = [D__namespace.BOOL, [D__namespace.LPTSTR, `_Inout_ ${D__namespace.LPDWORD}`]];
    /**
     * Retrieves information about a specified print job
     * https://learn.microsoft.com/en-us/windows/win32/printdocs/getjob
     * @param pJob JOB_INFO_1 or a JOB_INFO_2
     */
    static GetJobW = [D__namespace.BOOL, [D__namespace.HANDLE, D__namespace.DWORD, D__namespace.DWORD, `_Out_ ${D__namespace.LPBYTE}`, D__namespace.DWORD, `_Out_ ${D__namespace.LPDWORD}`]];
    /**
     * Retrieves information about a specified printer.
     * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/getprinter
     * @link https://learn.microsoft.com/zh-cn/windows/win32/printdocs/getprinter
     */
    static GetPrinterW = [D__namespace.BOOL, [
            D__namespace.HANDLE,
            D__namespace.DWORD,
            // multiple choice instead of `_Out_ ${D.LPBYTE}`,
            // @TODO 2|7
            [
                `_Out_ ${S__namespace.PPRINTER_INFO_1}`,
                `_Out_ ${S__namespace.PPRINTER_INFO_4}`,
                `_Out_ ${S__namespace.PPRINTER_INFO_5}`,
                `_Out_ ${S__namespace.PPRINTER_INFO_6}`,
                `_Out_ ${S__namespace.PPRINTER_INFO_8}`,
                `_Out_ ${S__namespace.PPRINTER_INFO_9}`,
            ],
            D__namespace.DWORD,
            `_Out_ ${D__namespace.LPDWORD}`,
        ]]; // `as const` is required for multipleChoice
    /**
     * Retrieves a handle to the specified printer or print server or other types of handles in the print subsystem.
     * @docs https://learn.microsoft.com/en-us/windows/win32/printdocs/openprinter
     * @docs https://learn.microsoft.com/zh-cn/windows/win32/printdocs/openprinter
     */
    static OpenPrinterW = [D__namespace.BOOL, [D__namespace.WString, `_Out_ ${D__namespace.LPHANDLE}`, S__namespace.PPRINTER_DEFAULTS]];
    /**
     * Notifies the print spooler that a document is to be spooled for printing.
     * @param pDocInfo A pointer to a DOC_INFO_1 structure that describes the document to print.
     * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/startdocprinter
     */
    static StartDocPrinterW = [D__namespace.DWORD, [D__namespace.HANDLE, D__namespace.DWORD, S__namespace.LPDOC_INFO_1]];
    /**
     * Notifies the spooler that a page is about to be printed on the specified printer.
     * @docs https://learn.microsoft.com/zh-cn/windows/win32/printdocs/startpageprinter
     */
    static StartPagePrinter = [D__namespace.BOOL, [D__namespace.HANDLE]];
    /**
     * Notifies the print spooler that data should be written to the specified printer.
     * @note Only supports GDI printing and must not be used for XPS printing
     * @link https://learn.microsoft.com/zh-cn/windows/win32/printdocs/writeprinter
     */
    static WritePrinter = [D__namespace.BOOL, [D__namespace.HANDLE, D__namespace.LPVOID, D__namespace.DWORD, `_Out_ ${D__namespace.LPDWORD}`]];
}

const funcName$7 = 'GetPrinterW';
const GetPrinterW_mapper = (name, runtimeArgs, defParamsArray) => {
    if (name !== funcName$7) {
        return;
    }
    const argLevel = runtimeArgs[1];
    const argPtr = S.getPRINTER_INFO_X_Ptr(argLevel);
    assert(argPtr, `getPRINTER_INFO_X_Ptr(${argLevel}) failed`);
    for (const row of defParamsArray) {
        assert(Array.isArray(row));
        const defPtr = row[2];
        if (defPtr.endsWith(argPtr)) {
            return row;
        }
    }
    // return [] // will throw Error
};

const multipleChoiceMapperList = new Map();
const multipleChoiceMapperSet = new Set();
multipleChoiceMapperList.set(funcName$7, multipleChoiceMapperSet);
multipleChoiceMapperSet.add(GetPrinterW_mapper);

const dllName = DllNames.winspool;
const load = (fns) => win32Def.load({
    dll: dllName,
    dllFuncs: DefWinspool,
    usedFuncNames: fns,
    multipleChoiceMapperList: multipleChoiceMapperList,
});

const funcName$6 = 'ClosePrinter';
// type RetType = ReturnType<FnType>
// type ParamType = Parameters<FnType>
/**
 * @link https://learn.microsoft.com/zh-cn/windows/win32/printdocs/closeprinter
 */
async function ClosePrinter(hwnd) {
    assert(hwnd, 'hwnd must be a valid handle');
    const lib = load([funcName$6]);
    const res = await lib.ClosePrinter_Async(hwnd);
    return !!res;
}

const funcName$5 = 'EndDocPrinter';
/**
 * @link https://learn.microsoft.com/zh-cn/windows/win32/printdocs/EndDocPrinter
 */
async function EndDocPrinter(hwnd) {
    assert(hwnd, 'hwnd must be a valid handle');
    const lib = load([funcName$5]);
    const res = await lib.EndDocPrinter_Async(hwnd);
    return !!res;
}

const funcName$4 = 'EnumPrintersW';
/**
 * Enumerates available printers, print servers, domains, or print providers.
 * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/enumprinters
 *
 * 枚举可用的打印机、打印服务器、域或打印提供程序
 * @link https://learn.microsoft.com/zh-cn/windows/win32/printdocs/enumprinters
 */
async function EnumPrinters(options) {
    const level = options.Level;
    const lib = load([funcName$4]);
    const name = '';
    // assert(level >= 1 && level <= 5, 'level must be >= 1 and <= 5')
    const cbBuf = options.cbBuf ?? 4096;
    assert(cbBuf > 2, 'cbBuf must be > 2');
    const buf = Buffer.alloc(cbBuf);
    const pcbNeeded = Buffer.alloc(4);
    const pcReturned = Buffer.alloc(4);
    const ret = await lib.EnumPrintersW_Async(options.Flags, name, level, buf, cbBuf, pcbNeeded, pcReturned);
    assert(ret, 'EnumPrintersW() failed');
    S.PRINTER_INFO_X_Factory(level);
    const count = pcReturned.readUInt32LE();
    // const pcb = pcbNeeded.readUInt32LE()
    const ptr = S.getPRINTER_INFO_X_Ptr(level);
    const key = ptr.replace(/\s*\*/u, ''); // 'PRINTER_INFO_1' | 'PRINTER_INFO_2'
    const decodeType = `${key}[${count}]`;
    const infoArr = win32Def.ffi.decode(buf, decodeType);
    return infoArr;
}

const funcName$3 = 'GetDefaultPrinterW';
/**
 * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/getdefaultprinter
 */
async function GetDefaultPrinter(maxNameLength = 256) {
    const lib = load([funcName$3]);
    assert(maxNameLength > 2, 'maxNameLength must be greater than 2');
    const len = maxNameLength + 1;
    const pszBuf = Buffer.alloc(len * 2);
    const pcchBuf = Buffer.alloc(4);
    pcchBuf.writeUint32LE(len);
    const ret = await lib.GetDefaultPrinterW_Async(pszBuf, pcchBuf);
    if (!ret) {
        // throw new Error('GetDefaultPrinterW() failed. May maxNameLength be too small?')
        return null;
    }
    const pcch = pcchBuf.readUInt32LE();
    if (pcch > 0) {
        const size = pcch - 1;
        const psz = win32Def.ucsBufferToString(pszBuf, size);
        return psz;
    }
    return '';
}

const funcName$2 = 'GetPrinterW';
// type RetType = ReturnType<FnType>
// type ParamType = Parameters<FnType>
/**
 * @link https://learn.microsoft.com/zh-cn/windows/win32/printdocs/getprinter
 */
async function GetPrinter(options) {
    const { hPrinter, Level, maxLength = 1024 } = options;
    const lib = load([funcName$2]);
    const pPrinter = {};
    const cbBuf = (maxLength + 1) * 2;
    const pcbNeeded = Buffer.alloc(8);
    const ret = await lib.GetPrinterW_Async(hPrinter, Level, pPrinter, cbBuf, pcbNeeded);
    const pcb = pcbNeeded.readUInt32LE();
    if (!ret) {
        if (pcb > maxLength) {
            throw new Error(`maxLength is too small, increase to value grater than ${pcb}`);
        }
        return null;
    }
    return pPrinter;
}

const funcName$1 = 'OpenPrinterW';
// type RetType = ReturnType<FnType>
// type ParamType = Parameters<FnType>
/**
 * Retrieves a handle to the specified printer or print server or other types of handles in the print subsystem
 * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/openprinter
 *
 * 检索指定打印机或打印服务器或打印子系统中其他类型的句柄的句柄
 * @link https://learn.microsoft.com/zh-cn/windows/win32/printdocs/openprinter
 */
async function OpenPrinter(printerName) {
    const lib = load([funcName$1]);
    const buf = Buffer.alloc(8);
    const res = await lib.OpenPrinterW_Async(printerName, buf, null);
    if (!res) {
        return null;
    }
    // const hwnd = ffi.address(buf)
    const hwnd = buf.readBigUInt64LE();
    return hwnd;
}

const funcName = 'StartDocPrinterW';
/**
 * Notifies the print spooler that a document is to be spooled for printing
 * @link https://learn.microsoft.com/en-us/windows/win32/printdocs/StartDocPrinter
 *
 * 函数通知打印后台处理程序文档将进行假脱机打印
 * @link https://learn.microsoft.com/zh-cn/windows/win32/printdocs/StartDocPrinter
 */
async function StartDocPrinter(options) {
    const { hPrinter, pDocInfo } = options;
    assert(hPrinter, 'hPrinter must be a valid handle');
    assert(pDocInfo, 'pDocInfo must be a valid');
    // assert(Buffer.isBuffer(pDocInfo), 'pDocInfo must be a valid pointer (Buffer)')
    const lib = load([funcName]);
    const Level = 1;
    const ret = await lib.StartDocPrinterW_Async(hPrinter, Level, pDocInfo);
    return !!ret;
}

exports.ClosePrinter = ClosePrinter;
exports.EndDocPrinter = EndDocPrinter;
exports.EnumPrinters = EnumPrinters;
exports.FindWindowEx = FindWindowEx;
exports.GetDefaultPrinter = GetDefaultPrinter;
exports.GetPrinter = GetPrinter;
exports.GetWindowText = GetWindowText;
exports.MessageBox = MessageBox;
exports.OpenPrinter = OpenPrinter;
exports.StartDocPrinter = StartDocPrinter;
//# sourceMappingURL=index.util.cjs.map
